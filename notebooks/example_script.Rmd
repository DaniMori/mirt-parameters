---
title: "Ejemplificando art"
author: "Mario Luzardo"
date: "2023-05-16"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls()) 
library(pspline)
library(mvtnorm)
library(sn)
library(mnormt)
library(scatterplot3d)
library(copula)
library(ggplot2)
library(fungible)
library(pracma)
library(matlib)
library(rgl)
set.seed(123)
```
En esta simulacion queremos ejemplificar lo habllado hasta la fecha
Prumeramente se generar'a la base canónica y una base no ortogonal $\mathfrak{B}$
Para simplifcar la base no ortogonal $\mathfrak{B}$  la normalizamos aunque esto no es necesario 


```{r base canonica, include=FALSE}
c_v1=c(1,0)
c_v2=c(0,1)
Base_C=matrix(cbind(c_v1,c_v2),ncol=2)
```

```{r base no ortogonal, include=FALSE}
b1_v1=c(1,4)
b1_v2=c(3,1)
b1_v1=b1_v1/len(b1_v1)
b1_v2=b1_v2/len(b1_v2)
Base_1=matrix(cbind(b1_v1,b1_v2),ncol=2)
```

La base no ortogonal  es: 

$\mathfrak{B}$=\{$v_1$=(`r b1_v1[1] `, `r b1_v1[2] `) ;$v_2$=(`r b1_v2[1] `, `r b1_v2[2] `) \}

Estos vectores tienen norma 1 y un ángulo entre ellos de `r round(matlib::angle(Base_1[,1],Base_1[,2]),2)` grados

Gráficamente los vectores de las bases canónica y B quedan


```{r grafico bases, echo=FALSE, include=TRUE}
plot(NA, xlim=c(-2,2), ylim=c(-2,2), xlab="X", ylab="Y")
vecs <- data.frame(vname=c("a","b"),x0=c(0,0,0,0),y0=c(0,0,0,0), x1=c(1,0,Base_1[1,1],Base_1[1,2]) ,y1=c(0,1,Base_1[2,1],Base_1[2,2]),col=1:4) 
with( vecs, mapply("arrows", x0, y0, x1,y1,col=col,lwd=3) )
with(vecs, mapply('text', x=x1[1:2]-.1, y=y1[1:2]+.1,labels=expression(list(a), list(b) ) ))
```


```{r angulos, include=FALSE}
alfa_1_1=matlib::angle(Base_1[,1],Base_C[,1])
alfa_1_2=matlib::angle(Base_1[,1],Base_C[,2])
alfa_2_1=matlib::angle(Base_1[,2],Base_C[,1])
alfa_2_2=matlib::angle(Base_1[,2],Base_C[,2])
```

Los ángulos con los ejes coordenados son:

Entre $v_1$ y $e_1$ `r round(alfa_1_1,2) ` grados

Entre $v_1$ y $e_2$ `r round(alfa_1_2,2) ` grados

Entre $v_2$ y $e_1$ `r round(alfa_2_1,2) ` grados

Entre $v_2$ y $e_2$ `r round(alfa_2_2,2) ` grados


Vamos a silular 2000 coordenadas en la base $\mathfrak{B}$. Tomaremos habilidades normales bivariadas correlacionadas 0.5 y con marginales normales típicas.

```{r coordenadas en B, include=FALSE}
CopulaNormal<-normalCopula(0.5, dim = 2, dispstr = "un")
MvdcNorm1<-mvdc(copula=CopulaNormal,margins=c("norm","norm"),paramMargins=list(list(mean=0,sd=1),list(mean=0,sd=1)))
coord_B<-rMvdc(2000,MvdcNorm1)
```

```{r coordenadas en C, include=FALSE}
P=Base_1
P_inv=solve(P)
P_invT=t(P_inv)
M=t(P)%*%P
coord_C <- t(apply(coord_B, 1, function(x) P %*% as.matrix(x)))
```

Los puntos quedan gráficamente

```{r coordenadas, echo=FALSE, include=TRUE}
plot(coord_C,xlim=c(-4,4),ylim=c(-4,4))
arrows(0, 0, 4*Base_1[1,1],4*Base_1[2,1] , lwd=3, col=2,code=2)
arrows(0, 0, 4*Base_1[1,2], 4*Base_1[2,2], lwd=3, col=2,code=2)
arrows(0, 0, -3*Base_1[1,1],-3*Base_1[2,1] , lwd=3, col=2,code=0)
arrows(0, 0, -3*Base_1[1,2], -3*Base_1[2,2], lwd=3, col=2,code=0)
grid()
```

En la base Canónica $\mathfrak{E}$ las coordenadas se obtienen mediante la matriz de cambio de base P

$$\theta^{\mathfrak{E}}=P\theta^{\mathfrak{B}}$$

```{r }
print(P)
```

Debemos observar que los puntos quedan fijos en el espacio lo que cambia son las coordenadas dado que P es la transformación identidad expresada en ambas bases.

Para mantener invariante la norma debemos definir en el espacio de la habilidad con la base B un producto interno con matriz de Gramm M
$$ M= P^T P$$
```{r }
print(M)
```

Por lo tanto la norma permanece invariante esto se puede comprobar mediante los comandos que siguen.

Consderamos un caso particular de habilidad


```{r norma, echo=TRUE, include=TRUE}
theta_C=coord_C[17,]
theta_C
theta_B=solve(Base_1,theta_C)
norma_B=as.numeric(sqrt(t(theta_B)%*%M%*%theta_B))
norma_C=as.numeric(sqrt(t(theta_C)%*%theta_C))
norma_B
norma_C
```


Es claro que al existir una transformación lineal sobre las coordenadas esto afectará a las varianzas (no a la distribución ya que partimos de una normal) y también las correlaciones.

Veremos como son estas relaciones en el siguiente código


```{r varianzas,echo=TRUE}
var(coord_B)
var(coord_C)
#Relacione entre las varianzas a partir de matrices
P%*%var(coord_B)%*%t(P)
cor(coord_B)
cor(coord_C)
#Relacione entre las correlaciones a partir de matrices

U=diag(diag(sqrt(var(coord_C))^(-1)))
   
U%*%P%*%var(coord_B)%*%t(P)%*%U
```

Veamos  como funciona la proposición 1 que dice que 

$$ cos\gamma^B=\frac{D^{-\frac{1}{2}}M \theta^B}{\| \theta \|}$$


```{r prop1,echo=TRUE}
D=diag(c(len(b1_v1),len(b1_v2)))
D_inv=solve(D)
normaC=apply(coord_C,1,len)
cosdir_B=NULL
for(i in 1: length(normaC)){
  aux=(D_inv^(0.5)%*%M%*%coord_B[i,])/normaC[i]  
  cosdir_B=rbind(cosdir_B,aux)
}
cosdir_B[1:5]
angulos=r2d(acos(cosdir_B))
angulos[1:5]
```
Observemos que la norma que tomamos en la funci'on es la norma respecto a la base canonica. Si queremos considerar la base no ortogonal debe calcularse la norma con el producto interno con matriz M


#Modelo

```{r modelo,include=FALSE}
a=c(0.5,1.5)
d=0.2
P_theta=NULL
for(i in 1:dim(coord_B)[1]){
  x=coord_B[i,]
  aux=1/(1+exp(-(t(a)%*%x+d)))
  P_theta=rbind(P_theta,aux)
}


a_p=P_invT%*%a
P_theta_C=NULL
for(i in 1:dim(coord_C)[1]){
  x=coord_C[i,]
  aux=1/(1+exp(-(t(a_p)%*%x+d)))
  P_theta_C=rbind(P_theta_C,aux)
}

```

Consideremos el modelo expresado en la base no ortogonal B con discriminación `r a` y d=`r d`


Con el cambio 

$$a_i^{'}=(P^{-1})^T a_i$$
se puede modelizar utilizando las coordenadas en la base can'onica

```{r comprueba}
P_theta[1:5]
P_theta_C[1:5]
```


#Cálculo de punto de máxima pendiente y pendiente

Los cosenos directores respecto a los ejes de la base canónica de la dirección del punto de máxima pendiente son

$$cos \gamma_i^E=\frac{a_i^{'}}{\sqrt{a_i^{'T}a_i^{'}}}$$
o con respecto a la base B

$$cos \gamma_i^B=\frac{D^{-\frac{1}{2}} a_i}{\sqrt{a_i^{T}M^{-1}a_i}}$$

La distencia al origen en esta dirección esta dada por

$$D_i=\frac{-d_i}{\sqrt{a_i^{T}M^{-1}a_i}}$$
y la pendiente
$$ S_i=\frac{\sqrt{a_i^{T}M^{-1}a_i}}{4}$$


```{r slope, include=FALSE}
cos_gamma_C=a_p/len(a_p)
M_inv=solve(M)
cos_gamma_B=(D_inv^(0.5)%*%a)/as.numeric(sqrt(t(a)%*%M_inv%*%a))
dista=-d/as.numeric(sqrt(t(a)%*%M_inv%*%a))
slope=as.numeric(sqrt(t(a)%*%M_inv%*%a))/4
```

Obtenemos

$cos \gamma_i^E$= `r cos_gamma_C`

$cos \gamma_i^B$= `r cos_gamma_B`

$D_i$=`r dista`

$S_i$= `r slope`

El ángulo con los ejes de la base canónica es `r r2d(acos(cos_gamma_C))`

Graficamos un vector cuya norma es $S_i$ aplicado sobre el punto donde se da el m'aximo slope

```{r graslope}
m=cos_gamma_C[2]/cos_gamma_C[1]
punto_x=(dista/abs(dista))*sqrt(dista^2/(1+m^2))
punto_y=m*punto_x

plot(coord_C,xlim=c(-4,4),ylim=c(-4,4))
arrows(0, 0, 4*Base_1[1,1],4*Base_1[2,1] , lwd=3, col=2,code=2)
arrows(0, 0, 4*Base_1[1,2], 4*Base_1[2,2], lwd=3, col=2,code=2)
arrows(0, 0, -3*Base_1[1,1],-3*Base_1[2,1] , lwd=3, col=2,code=0)
arrows(0, 0, -3*Base_1[1,2], -3*Base_1[2,2], lwd=3, col=2,code=0)
points(punto_x, punto_y,lwd=4, col=5)
grid()

```

En un grafico de perspectiva tenemos
```{r perspe}
x=seq(-3,3,length=100)
y=seq(-3,3,length=100)

ICC=function(x,y){1/(1+exp(-(a_p[1]*x+a_p[2]*y+d)))}

z=outer(x, y, ICC)
persp(x,y,z,phi=40,border=NA,col="blue")

image(x,y,z)
contour(x,y,z,add=T)
points(punto_x,punto_y,lwd=4, col=5)

```