---
title: 'Graphical representation example: Alternative interpretations'
output:
  html_document: 
    df_print:        paged
    code_folding:    hide
    toc:             yes
    toc_float:       yes
editor_options: 
  chunk_output_type: console
---

```{r setup}
library(knitr)
library(patchwork)
library(rstudioapi)

ROOT_DIR <- getActiveProject()
DOC_DIR  <- getwd()

opts_knit$set(root.dir = ROOT_DIR)
opts_chunk$set(
  echo     = TRUE,
  message  = FALSE,
  cache    = FALSE,
  dev      = "png",
  dpi      =   300,
  dev.args = list(type = "cairo-png")
)

# Output configuration options:
options(digits = 3)
```

# Introduction

After the 2023/11/02 discussion, there are two issues that remain unclear
regarding the graphical representation of the items.

1. Whether the correlation-based or the covariance-based matrix should be used
in the graphical representation, and whether it has an effect on its interpretation.

2. The need to represent the items in the latent vs. the test space.

We have a look at the example changing these two issues to see the effect.

# Preface

```{r read-chunks-graphical-example}
#| echo: false
read_chunk("src/Graphical_example_paper.R")
```

Load libaries:

```{r libraries}
```

Source R scripts:

```{r sources}
```

Define constants:

```{r constants}
```

Configure graphical output:

```{r graphical-output-conf}
```

# Covariance-based parameters and representation

As I say in the draft, my understanding is that the correlation-based version of
the parameters should be used for the graphical representation, as these are
scale preserving, and therefore can be interpreted straightforwardly.

We first compute the original item parameters and coordinates:

```{r compute-example-items}
```

## MCLM parameters

For reference, the MCLM version of the parameters, along with the "orthogonal"
(i.e. agnostic) ones, are:

```{r example-items-table-out}
item_params |> select(-ends_with("_obl"))
```

## Parameters and representation in the original oblique space

The graphical representation (only the oblique version is shown), as computed in
the draft, is:

```{r compose-oblique-plot}
```

```{r compose-orthogonal-plot}
```

```{r item-plot-out}
#| fig.cap: |
#|   Item plots in an oblique test space, with original (i.e., standard)
#|   covariance matrix
plot_oblique + scale_color_manual(values = PALETTE)
```

And the correlation-based parameters and coordinates:

```{r example-items-obl-out}
items_oblique
```

## Parameters and representation in oblique space with different variances

Let's now compute a covariance-based version of the parameters. In this case,
we defined the variances of the two latent dimensions as 1, so the
covariance-based and the correlation-based versions of the indices are the same.
In order to solve this, we define a new covariance matrix where the variance are
different from 1. We set them to $[2, 1.5]$ instead:

```{r define-cov-matrix}
VARIANCES  <- c(2, 1.5)
sd_matrix  <- VARIANCES |> sqrt() |> diag()
cov_matrix <- sd_matrix %*% corr_matrix %*% sd_matrix
```

With this covariance matrix, we compute the item parameters again:

```{r recompute-oblique-items}
# Oblique case:

## Compute parameters and coordinates:
items_oblique_params <- items_M2PL |> compute_mirt_params(
  all_of(INTERCEPT_COLKEY), starts_with(DISCR_PREFFIX), # Input parameters
  cov_matrix = cov_matrix,                              # Input covariances
  dir_out    = c(COSINE_DIRTYPE, DEGREE_DIRTYPE)        # Output configuration
)
items_oblique_coords <- items_oblique_params |> compute_mirt_coords(
  D, MDISC, starts_with(COSINE_DIRTYPE),
  transform       = transform_matrix,
  original_coords = FALSE
)
items_oblique        <- full_join(
  items_oblique_params, items_oblique_coords,
  by = ITEM_COLKEY
)

# Create the parameter table again:
item_params <- items_M2PL |> full_join(
  items_oblique |> select(item:deg_2, -starts_with(COSINE_DIRTYPE)),
  by = ITEM_COLKEY
)
```

```{r example-items-obl-out}
```

As can be seen, the directions change, due to the difference in the scale of the
two dimensions induced by the different variances. The resulting graphical
representation is:

```{r compose-oblique-plot}
```

```{r item-plot-cov-out}
#| fig.cap: |
#|   Item plots in an oblique test space, with variances [2, 1.5]
plot_oblique +
  scale_x_continuous(
    limits       = c(-2, 4.2),
    breaks       = (0:4) - 2 / CORR_ARC_TAN,
    labels       = 0:4,
    minor_breaks = NULL,
    name         = NULL,
    oob          = oob_keep
  )          +
  scale_color_manual(values = PALETTE)
```

### Interpretation

The vectors are "stretched" in both directions, due to the different variances.
The "length" by which they are scaled depends on the standard deviation of each
dimension. In this case, we are using variances of 2 and 1.5. Therefore, the
vectors are stretched more in the first (horizontal) direction than in the
second (oblique) one.

## Case with more predictable results

My expectations were that the representation if the items would be independent
of the covariance matrix, but this has not been the case. I had not predicted
that the item vectors would be "stretched" in space, as has happened, although I
should have expected this because I mention it in the draft, in section 3.3
(Properties of the parameters). Therefore, I acknowledge this representation is
the correct one.

In order to test the prediction that the items are scaled by the standard
deviation, let's test a case that is easier to predict. In order to it, I will
use variances of 0.25, which result in standard deviations of 0.5. Then, if my
understanding of the representation of the vectors is correct, all the vectors
should be scaled by $tfrac{1}{2}$; that is, they should have half the original
length. Their direction however should not change.

```{r define-cov-matrix-prediction}
VARIANCES  <- c(.25, .25)
sd_matrix  <- VARIANCES |> sqrt() |> diag()
cov_matrix <- sd_matrix %*% corr_matrix %*% sd_matrix
```

```{r recompute-oblique-items}
```

```{r example-items-obl-out}
```

```{r compose-oblique-plot}
```

```{r item-plot-cov-prediction-out}
#| fig.cap: |
#|   Item plots in an oblique test space, with variances [0.25, 0.25]
plot_oblique + scale_color_manual(values = PALETTE)
```

### Interpretation

The resulting MIDSC parameters are effectively half the length, as predicted.
On the other hand, as the MIL is affected by the inverse of the MDICS, the MIL
values are the double of the original ones. This result in vectors that are not
only half the length of the originals. Also, their origin is twice as far from
the origin of the latent space.

## Conclusions

The graphical representation reflects correctly the values of the parameters.
However, the coordinates of the parameters in the latent space do not reflect
the values of the original MCLM parameters.

This is the reason why I understand that a correlation-based representation is
more appropriate.
