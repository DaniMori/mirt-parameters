---
title: 'Graphical representation example: Alternative interpretations'
output:
  html_document: 
    df_print:        paged
    code_folding:    hide
    toc:             yes
    toc_float:       yes
editor_options: 
  chunk_output_type: console
---

```{r setup}
library(knitr)
library(patchwork)
library(rstudioapi)

ROOT_DIR <- getActiveProject()
DOC_DIR  <- getwd()

opts_knit$set(root.dir = ROOT_DIR)
opts_chunk$set(
  echo     = TRUE,
  message  = FALSE,
  cache    = FALSE,
  dev      = "png",
  dpi      =   300,
  dev.args = list(type = "cairo-png")
)

# Output configuration options:
options(digits = 3)
```

# Introduction

After the 2023/11/02 discussion, there are two issues that remain unclear
regarding the graphical representation of the items.

1. Whether the correlation-based or the covariance-based matrix should be used
in the graphical representation, and whether it has an effect on its interpretation.

2. The need to represent the items in the latent vs. the test space.

We have a look at the example changing these two issues to see the effect.

# Preface

```{r read-chunks-graphical-example}
#| echo: false
read_chunk("src/Graphical_example_paper.R")
```

Load libaries:

```{r libraries}
```

Source R scripts:

```{r sources}
```

Define constants:

```{r constants}
```

Configure graphical output:

```{r graphical-output-conf}
```

# Covariance-based parameters and representation

As I say in the draft, my understanding is that the correlation-based version of
the parameters should be used for the graphical representation, as these are
scale preserving, and therefore can be interpreted straightforwardly.

We first compute the original item parameters and coordinates:

```{r compute-example-items}
```

## MCLM parameters

For reference, the MCLM version of the parameters, along with the "orthogonal"
(i.e. agnostic) ones, are:

```{r example-items-table-out}
item_params |> select(-ends_with("_obl"))
```

## Parameters and representation in the original oblique space

The graphical representation (only the oblique version is shown), as computed in
the draft, is:

```{r compose-oblique-plot}
```

```{r compose-orthogonal-plot}
```

```{r item-plot-out}
#| fig.cap: |
#|   Item plots in an oblique test space, with original (i.e., standard)
#|   covariance matrix
plot_oblique + scale_color_manual(values = PALETTE)
```

And the correlation-based parameters and coordinates:

```{r example-items-obl-out}
items_oblique
```

## Parameters and representation in oblique space with different variances

Let's now compute a covariance-based version of the parameters. In this case,
we defined the variances of the two latent dimensions as 1, so the
covariance-based and the correlation-based versions of the indices are the same.
In order to solve this, we define a new covariance matrix where the variance are
different from 1. We set them to $[2, 1.5]$ instead:

```{r define-cov-matrix}
VARIANCES  <- c(2, 1.5)
sd_matrix  <- VARIANCES |> sqrt() |> diag()
cov_matrix <- sd_matrix %*% corr_matrix %*% sd_matrix
```

With this covariance matrix, we compute the item parameters again:

```{r recompute-oblique-items}
# Oblique case:

## Compute parameters and coordinates:
items_oblique_params <- items_M2PL |> compute_mirt_params(
  all_of(INTERCEPT_COLKEY), starts_with(DISCR_PREFFIX), # Input parameters
  cov_matrix = cov_matrix,                              # Input covariances
  dir_out    = c(COSINE_DIRTYPE, DEGREE_DIRTYPE)        # Output configuration
)
items_oblique_coords <- items_oblique_params |> compute_mirt_coords(
  D, MDISC, starts_with(COSINE_DIRTYPE),
  transform       = transform_matrix,
  original_coords = FALSE
)
items_oblique        <- full_join(
  items_oblique_params, items_oblique_coords,
  by = ITEM_COLKEY
)

# Create the parameter table again:
item_params <- items_M2PL |> full_join(
  items_oblique |> select(item:deg_2, -starts_with(COSINE_DIRTYPE)),
  by = ITEM_COLKEY
)
```

```{r example-items-obl-out}
```
