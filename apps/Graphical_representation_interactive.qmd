---
title: "MCLM parameters, interactive example"
author: "Daniel Morillo"
format:
  html:
    fig-asp: 1
server: shiny
---

```{r setup}
#| warning: false
library(shinyjs)
library(tibble)
library(mnormt)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(scales)
```

```{r constants}
#| context: server
# Graphical representation parameters:
GRAPH_FONT   <- "serif"
LINE_WIDTH   <- .1
VECTOR_WIDTH <- .5
PALETTE      <- c("darkred", "darkgoldenrod3", "green3", "cyan3", "blue3")
```

```{r graphical-output-conf}
#| context: server
theme_set( # `ggplot` output configuration
  theme_classic(
    base_size      = 12,
    base_family    = GRAPH_FONT,
    base_line_size = LINE_WIDTH
  ) %+replace%
    theme(
      axis.title.x = element_text(hjust = 1),
      axis.title.y = element_text(vjust = 1, angle = 0)
    )
)
```

# Description

This app show an interactive graphical representation of the Multidimensional
parameters (location and discrimination) of the Multidimensional Compensatory
Logistic IRT Model (MCLM).

# Input

## MCLM item parameters

```{r item-params-input}
#| layout: [[1], [1], [1]]
numericInput('a_1', label = 'a1', value = 1, step = .1, min = -3, max = 3)
numericInput('a_2', label = 'a2', value = 1, step = .1, min = -3, max = 3)
numericInput('d',   label = 'd',  value = 0, step = .1, min = -3, max = 3)
```

```{r compute-item}
#| context: server

# Logic for computing the item object:
item_M2PL <- reactiveVal()

observeEvent(
  list(input$a_1, input$a_2, input$d),
  item_M2PL(tibble(item = 1, a_1 = input$a_1, a_2 = input$a_2, d = input$d))
)
```

## Latent space structure

### Covariance matrix

```{r cov-input}
#| layout: [[1, 1], [1, 1]]
numericInput('var_1', label = 'var1', value = 1, step = .1, min = .1, max = 3)
textOutput('cov1')
textOutput('cov2')
numericInput('var_2', label = 'var2', value = 1, step = .1, min = .1, max = 3)
```

### Correlation matrix

```{r corr-input}
#| layout: [[1, 1], [1, 1]]
h5("1")
numericInput(
  'corr',
  label = 'corr',
  value = 0,
  step  =  .05,
  min   = -.95,
  max   =  .95
)
textOutput('corr_lower')
h5("1")
```

```{r compute-ls}
#| context: server

# Logic for computing & rendering the latent space structure:

## Values and matrices:
covariance        <- reactiveVal() # Covariance value
cov_matrix        <- reactiveVal() # Covariance matrix
corr_matrix       <- reactiveVal() # Correlation matrix
transf_inv_transp <- reactiveVal() # Transpose inverse of the latent space
                                   #   transform matrix (== Square root of
                                   #   the correlation matrix scaled by the
                                   #   standard deviations).
transf_matrix     <- reactiveVal() # Latent space transform matrix

## Compute covariance:
observeEvent(
  list(input$var_1, input$var_2, input$corr),
  covariance(sqrt(input$var_1 * input$var_2) * input$corr)
)

## Compute covariance matrix:
observeEvent(
  list(input$var_1, input$var_2, covariance()),
  cov_matrix(
    matrix(c(input$var_1, covariance(), covariance(), input$var_2), nrow = 2)
  )
)

## Compute correlation matrix:
observeEvent(
  input$corr,
  corr_matrix(matrix(c(1, input$corr, input$corr, 1), nrow = 2))
)

## Compute (inverse transposed) transform matrix:
observeEvent(
  cov_matrix(),
  transf_inv_transp({
    
    # Square root of the correlation matrix (conveniently fixing the X axis):
    corr_sqrt_matrix <- matrix(
      c(1, 0, input$corr, sqrt(1 - input$corr^2)),
      nrow = 2
    )
    
    # Scale matrix (i.e. standard deviations):
    scale_matrix <- cov_matrix() |> diag() |> diag() |> sqrt()
    
    corr_sqrt_matrix %*% scale_matrix
  })
)
# Compute actual (P) transform matrix (such that $P^TP = M = \Sigma^(-1)$):
observeEvent(
  transf_inv_transp(),
  transf_matrix(transf_inv_transp() |> t() |> solve())
)


## Output correlation and covariance values:
output$corr_lower <- renderText(input$corr)
output$cov1       <- renderText(covariance() |> round(2))
output$cov2       <- renderText(covariance() |> round(2))
```

## Sample

```{r sample-choice}
radioButtons(
  'sample_type',
  label   = "Plot:",
  choices = c("unique value", "sample"),
  inline  = TRUE
)
```

```{r single-value}
#| panel: sidebar
numericInput(
  'theta_1',
  label = 'theta_1',
  value =  1,
  step  =   .1,
  min   = -3,
  max   =  3
)
numericInput(
  'theta_2',
  label = 'theta_2',
  value =  1,
  step  =   .1,
  min   = -3,
  max   =  3
)
```

```{r sample-size}
#| panel: sidebar
numericInput('N', label = 'N', value = 10, min = 10, max = 1000)
```

```{r compute-sample}
#| context: server

# Logic for computing & rendering the sample values:

# Sample values:
single_lt        <- reactiveVal() # Single latent trait vector
complete_sample  <- reactiveVal() # A N = 1000 sample is pre-computed to save
                                  #   time (it only changes if the covariance
                                  #   matrix changes).
n_subsample      <- reactiveVal() # Subsets the first N cases
lt_sample        <- reactiveVal() # Sample to plot
lt_sample_transf <- reactiveVal() # Transformed coordinates of sample to plot

# Compute single vector:
observe(
  single_lt(tibble(theta_1 = input$theta_1, theta_2 = input$theta_2))
)

# Compute complete sample:
observeEvent(
  cov_matrix(),
  complete_sample(
    rmnorm(n = 1000, varcov = cov_matrix()) |>
    as_tibble(.name_repair = "unique") |>
    rename_with(str_replace, pattern = "\\.{3}", replacement = "theta_")
  )
)

# Compute N subset sample:
observeEvent(
  list(input$N, complete_sample()),
  n_subsample(complete_sample() |> slice_head(n = input$N))
)

# Select sample to plot:
observeEvent(
  list(input$sample_type, single_lt(), n_subsample()),
  lt_sample(if (input$sample_type == "sample") n_subsample() else single_lt())
)

# Transform sample coordinates to orthonormal space:
observeEvent(
  list(transf_inv_transp(), lt_sample()),
  lt_sample_transf({
    
    # Compute actual (P) transform matrix (such that $P^TP = M = \Sigma^(-1)$):
    transf_matrix <- transf_inv_transp() |> t() |> solve()
    
    # Compute coordinates in transformed (i.e. orthonormal) space:
    lt_sample() |>
      rowid_to_column() |>
      pivot_longer(-rowid) |>
      group_by(rowid) |>
      mutate(value = transf_matrix %*% value |> drop()) |>
      pivot_wider()
  })
)

## FIXME: Disabling inputs does not work
# useShinyjs()
# observeEvent(
#   input$sample_type == "unique value",
#   disable('N')
# )
# observeEvent(
#   input$sample_type == "sample",
#   {
#     disable('theta_1')
#     disable('theta_2')
#   }
# )
```

# Output

# Item multidimensional parameters

```{r item-output}
tableOutput('item')
```

```{r compute-multidim-params}
#| context: server
#| warning: false

# Multidimensional item parameters logic:

source("R/Mirt_toolbox.R", encoding = 'UTF-8')
source("R/Constants.R",    encoding = 'UTF-8')

item_oblique <- reactiveVal()

observeEvent(
  list(input$a_1, input$a_2, input$d, cov_matrix()),
  item_oblique({
    oblique_params <- item_M2PL() |> compute_mirt_params(
      all_of(INTERCEPT_COLKEY), starts_with(DISCR_PREFFIX), # Input parameters
      cov_matrix = cov_matrix(),                            # Input covariance
      dir_out    = c(COSINE_DIRTYPE, DEGREE_DIRTYPE)        # Output config.
    )
    oblique_coords <- oblique_params |> compute_mirt_coords(
      D, MDISC, starts_with(COSINE_DIRTYPE),
      transform       = cov_matrix(),
      original_coords = TRUE
    )
    
    full_join(oblique_params, oblique_coords, by = 'item')
  })
)

output$item <- renderTable(
  item_oblique() |> select(MDISC, D, starts_with('deg'))
)
```

## Plots

```{r plot-outputs}
#| layout: [[1, 1], [1, 1]]
plotOutput('ls_original')
plotOutput('ts_original')
plotOutput('ls_transformed')
plotOutput('ts_transformed')
```

```{r render-plots}
#| context: server

draw_spikes <- reactiveVal() # Flag to indicate whether to draw spikes (for
                             #   single value plotting only)
observeEvent( ## TODO: Draw spikes
  input$sample_type,
  draw_spikes(input$sample_type == "unique value")
)

# Render scatter plot in original coordinates:
output$ls_original <- renderPlot(
  
  lt_sample() |> ggplot(aes(x = theta_1, y = theta_2)) +
    geom_vline(xintercept = 0, linewidth = LINE_WIDTH) +
    geom_hline(yintercept = 0, linewidth = LINE_WIDTH) +
    geom_point(alpha = .5) +
    scale_x_continuous(
      limits       = c(-3, 3),
      breaks       = -3:3,
      minor_breaks = NULL,
      name         = NULL,
      oob          = oob_keep
    ) +
    scale_y_continuous(
      limits       = c(-3, 3),
      breaks       = -3:3,
      name         = NULL,
      oob          = oob_keep
    ) +
    coord_fixed(expand = FALSE, clip = "on") +
    theme(
      axis.line        = element_blank(),
      panel.grid.major = element_line(
        color     = "black",
        linewidth = LINE_WIDTH,
        linetype  = "C6"
      )
    ) +
    xlab("theta_1") + ## FIXME: Labels not shown
    ylab("theta_2")
)

# Render scatter plot in transformed coordinates:
output$ts_original <- renderPlot({
})
output$ls_transformed <- renderPlot({
  
  # Constant objects:
  BREAKS <- -3:3
  
  # Compute grid lines:
  
  ## Basis vectors:
  basis_vec_1 <- transf_matrix()[, 1]
  basis_vec_2 <- transf_matrix()[, 2]
  basis_vec_1_norm <- basis_vec_1^2 |> sum() |> sqrt()
  basis_vec_2_norm <- basis_vec_2^2 |> sum() |> sqrt()
  
  ## Oblique grid lines:
  tan_vec_1 <- basis_vec_1[2] / basis_vec_1[1] # Angle tangent
  

  lt_sample_transf() |> ggplot(aes(x = theta_1, y = theta_2)) +
    geom_vline(xintercept = 0, linewidth = LINE_WIDTH) +
    geom_abline( # Oblique `theta_2` axis
      intercept = 0,
      slope     = tan_vec_1,
      linewidth = LINE_WIDTH
    ) +
    geom_abline( # Oblique panel grid lines
      intercept = -3:3 * basis_vec_2[2],
      slope     = tan_vec_1,
      linewidth = LINE_WIDTH,
      linetype  = "C6"
    ) +
    geom_point(alpha = .5) +
    scale_x_continuous(
      limits       = c(-3, 3),
      breaks       = -3:3,
      minor_breaks = NULL,
      name         = NULL,
      oob          = oob_keep
    ) +
    scale_y_continuous(
      limits       = c(-3, 3),
      breaks       = -3:3,
      name         = NULL,
      oob          = oob_keep
    ) +
    coord_fixed(expand = FALSE, clip = "on") +
    theme(
      axis.line          = element_blank(),
      panel.grid.major.x = element_line(
        color     = "black",
        linewidth = LINE_WIDTH,
        linetype  = "C6"
     )
    )
})
output$ts_transformed <- renderPlot({
})
```

