---
title: "Generalized multidimensional parameters of the MCLM"
author: "Daniel Morillo, Mario Luzardo"
date: "`r Sys.Date()`"
output:
  officedown::rdocx_document:
    tables:
      style: APA_Like_style
    mapstyles:
      Normal: First Paragraph
    base_format: bookdown::word_document2
    reference_docx: ../../www/Template.docx
    number_sections: no
    keep_md:         no
    fig_width:       4
    fig_height:      4
bibliography: ../../www/Multidimensional-parameters-MCLM.bib
csl:          ../../www/apa-old-doi-prefix.csl
editor_options: 
  chunk_output_type: console
---


```{r setup, include=FALSE}
library(knitr)
library(scales)
library(tidyverse)
library(latex2exp)
library(magrittr)
library(ggforce)
library(pBrackets)
library(glue)
library(flextable)
library(ftExtra)


ROOT_DIR <- "../.."
DOC_DIR <- getwd()

opts_knit$set(root.dir = ROOT_DIR)
opts_chunk$set(
  echo     = FALSE,
  cache    = FALSE,
  dev      = "png",
  dpi      =   300,
  dev.args = list(type = "cairo-png"),
  fig.pos = "!H"
)

# Constants:
GRAPH_FONT   <- "serif"
LINE_WIDTH   <- .1
VECTOR_WIDTH <- 1.5
ANGLE_WIDTH  <- .5
POINT_CHAR   <- 19L


# Output configuration options:
options(digits = 4)
theme_set(
  theme_classic(
    base_size      = 12,
    base_family    = GRAPH_FONT,
    base_line_size = LINE_WIDTH
  ) %+replace%
  theme(
    axis.title.x = element_text(hjust = 1),
    axis.title.y = element_text(vjust = 1, angle = 0)
  )
)
```


```{r includes, cache=FALSE}
source("R/Formulas.R", encoding = 'UTF-8')
source("R/Graphical_example_transcriptions_Mario.R", encoding = 'UTF-8')
source("R/Output.R", encoding = 'UTF-8')
```


# Direction of the maximal slope from the origin in the MUPP-2PL model

## Original derivation by Mario Luzardo (circa 13-07-2018)

First,

\begin{equation}
  f_2(\theta_1, \theta_2) = `r LOGISTIC_RECT`                  (\#eq:model-rect)
\end{equation}

is equivalent to

\begin{equation}
  `r F_THETA_ALPHA` = `r LOGISTIC_POLAR`,                     (\#eq:model-polar)
\end{equation}

with

\begin{equation}
  \begin{split}
    \theta_1 = `r THETA_COS_ALPHA`, \\
    \theta_2 = `r THETA_SIN_ALPHA`.
  \end{split}                                             (\#eq:transform-polar)
\end{equation}


The first derivative of $`r F_THETA_ALPHA`$ (for $\theta$) is

\begin{equation}
  \begin{split}
    `r F_THETA_ALPHA_DIFF_THETA` & =
      \frac{`r EXPFUNC_POLAR`}{(`r LOG_DENOM_POLAR`)^2} `r A_COS_SIN_POLAR` \\
    & = `r LOGISTIC_POLAR` \\
      `r LOG_INV_POLAR` `r A_COS_SIN_POLAR` \\
    & = `r F_THETA_ALPHA` `r F_THETA_ALPHA_1_MINUS` `r A_COS_SIN_POLAR`.
  \end{split}                                           (\#eq:first-deriv-theta)
\end{equation}


Then, the second derivative (for $\theta$) is

\begin{equation}
  \begin{split}
    `r F_THETA_ALPHA_DIFF2_THETA` &=
      `r F_THETA_ALPHA` `r F_THETA_ALPHA_1_MINUS`^2 `r A_COS_SIN_POLAR`^2 - \\
      &`r F_THETA_ALPHA`^2 `r F_THETA_ALPHA_1_MINUS` `r A_COS_SIN_POLAR`^2 \\
      &= `r F_THETA_ALPHA` `r F_THETA_ALPHA_1_MINUS` `r A_COS_SIN_POLAR`^2
        [1 - 2 `r F_THETA_ALPHA`] \\
      &= `r A_COS_SIN_POLAR`^2 `r F_THETA_ALPHA`
        [1 - 3 `r F_THETA_ALPHA` + 2 `r F_THETA_ALPHA`^2].
  \end{split}                                          (\#eq:second-deriv-theta)
\end{equation}


The condition the multidimensional slope parameter must satisfy is

\begin{equation}
  `r F_THETA_ALPHA_DIFF2_THETA` = 0
    \Leftrightarrow
    `r F_THETA_ALPHA` = `r FRAC_1_2`.           (\#eq:condition-max-slope-theta)
\end{equation}


The slope is maximal (across $\theta$) if
$`r F_THETA_ALPHA` = \tfrac{1}{2}$,
and the maximal slope equals $\tfrac{1}{4} `r A_COS_SIN_POLAR`$.

For which $\alpha$ (i.e., in which direction) is

\begin{equation}
  `r ZETA_ALPHA` \coloneqq `r FRAC_1_4` `r A_COS_SIN_POLAR`
                                                           (\#eq:zeta-alpha-def)
\end{equation}

maximal?


\begin{equation}
  `r ZETA_ALPHA` = `r FRAC_1_4`
    \left( `r A1_COS_ALPHA` - `r A2_SIN_ALPHA_AS_COS` \right)
                                                           (\#eq:zeta-alpha-cos)
\end{equation}


\begin{equation}
  `r ZETA_ALPHA_DIFF_COS_ALPHA` =
    `r FRAC_1_4` a_1 +
      `r FRAC_1_4` a_2 \frac{`r COS_ALPHA`}{`r SIN_ALPHA_AS_COS`}
                                                         (\#eq:zeta-first-deriv)
\end{equation}


\begin{equation}
  \begin{split}
    `r ZETA_ALPHA_DIFF_COS_ALPHA` = 0
      & \Leftrightarrow
        a_1 + a_2 \frac{`r COS_ALPHA`}{`r SIN_ALPHA_AS_COS`} = 0 \\
      & \Leftrightarrow
        a_2 `r COS_ALPHA` = - a_1 `r SIN_ALPHA_AS_COS` \\
      & \Leftrightarrow
        a_2^2 `r COS_SQ_ALPHA` = (- a_1)^2 (1 - `r COS_SQ_ALPHA`) \\
      & \Leftrightarrow
        (a_1^2 + a_2^2) `r COS_SQ_ALPHA` = (- a_1)^2 \\
      & \Leftrightarrow
        `r COS_ALPHA` = `r MINUS_A1_OVER_SQRT_A_SQ`
  \end{split}                                   (\#eq:zeta-first-deriv-solution)
\end{equation}


That is, the maximal slope (in the direction from the origin) is found when

\begin{equation}
  `r COS_ALPHA` = `r MINUS_A1_OVER_SQRT_A_SQ`   (\#eq:condition-max-slope-alpha)
\end{equation}

and $\theta$ is such that $`r F_THETA_ALPHA` = \tfrac{1}{2}$.

The latter occurs when

\begin{equation}
  \begin{split}
    `r F_THETA_ALPHA` = `r LOGISTIC_MAX_THETA` = `r FRAC_1_2`
      \Leftrightarrow
      \theta = \frac {-l}{`r SQRT_A1_A2_SQUARED`}.
                                                 (\#eq:max-slope-alpha-solution)
  \end{split}
\end{equation}


## Highlights

- This derivation assumes orthogonality of the latent space, as per Equation
\@ref(eq:transform-polar).

- This document was handwritten by Mario (circa 13 July 2018),
and it is likely that the idea of generalizing to a non-orthonormal space was
still not mature by then.
The transformation of Equation \@ref(eq:zeta-alpha-def) into \@ref(eq:zeta-alpha-cos)
is the first step where the (implicit) orthogonality assumption
becomes relevant.

- Note also that these derivations apply to the MUPP-2PL model.
Clearly they are equivalent to the MCLM model derivations in
[@reckase_difficulty_1985].
However, precisely because of this equivalence,
the orthogonality assumption is equally implicit.


## Development of some steps

Some steps are rather complex so I expand the intermediate steps in order to
clarify the derivation.


### First derivative of $f(\theta, \alpha)$

The first step applies the rule
$\frac{\delta}{\delta x} \tfrac{1}{g(x)} = - \tfrac{g'(x)}{g^2(x)}$;
with

\begin{equation}
  \begin{split}
    g(\theta) &= `r LOG_DENOM_POLAR` \\
              &= 1 + \exp{[-`r A_COS_SIN_POLAR` \theta - l]},
  \end{split}                                        (\#eq:inv-rule-exponential)
\end{equation}

\begin{equation}
  g'(\theta) = - `r A_COS_SIN_POLAR` `r EXPFUNC_POLAR`
                                                   (\#eq:derivative-exponential)
\end{equation}


\begin{equation}
  \begin{split}
    `r F_THETA_ALPHA_DIFF_THETA` & = -
      \frac{ - `r A_COS_SIN_POLAR` `r EXPFUNC_POLAR` }
           {(`r LOG_DENOM_POLAR`)^2} \\
      & = \frac{`r EXPFUNC_POLAR`} {(`r LOG_DENOM_POLAR`)^2} `r A_COS_SIN_POLAR`
  \end{split}                                 (\#eq:first-deriv-theta-developed)
\end{equation}


### Second derivative of $`r F_THETA_ALPHA`$

First, the terms
$`r A_COS_SIN_POLAR`^2 `r F_THETA_ALPHA` `r F_THETA_ALPHA_1_MINUS`$
are extracted as a common factor:

\begin{equation}
  \begin{split}
    `r F_THETA_ALPHA_DIFF2_THETA` & =
      `r F_THETA_ALPHA` `r F_THETA_ALPHA_1_MINUS`^2 `r A_COS_SIN_POLAR`^2 - \\
        `r F_THETA_ALPHA`^2 `r F_THETA_ALPHA_1_MINUS` `r A_COS_SIN_POLAR`^2 \\
      & = `r DIFF2_COMMON_FACTOR` `r F_THETA_ALPHA_1_MINUS` - \\
        `r DIFF2_COMMON_FACTOR` `r F_THETA_ALPHA` \\
      & = `r DIFF2_COMMON_FACTOR` [1 - `r F_THETA_ALPHA` - `r F_THETA_ALPHA`] \\
      & = `r DIFF2_COMMON_FACTOR` [1 - 2 `r F_THETA_ALPHA`] \\
      & = `r DIFF2_COMMON_FACTOR_ALT_ORDER` [1 - 2 f(\theta, \alpha)].
  \end{split}                                (\#eq:second-deriv-theta-developed)
\end{equation}


Then, the product
$`r F_THETA_ALPHA_1_MINUS` [1 - 2 f(\theta, \alpha)]$
is expanded:

\begin{equation}
  \begin{split}
    `r F_THETA_ALPHA_DIFF2_THETA` & =
      `r DIFF2_COMMON_FACTOR_ALT_ORDER` [1 - 2 f(\theta, \alpha)] \\
      & = `r A_COS_SIN_POLAR`^2 `r F_THETA_ALPHA`
        [1 - 2`r F_THETA_ALPHA` - `r F_THETA_ALPHA` + 2f^2(\theta, \alpha) ] \\
      & = `r A_COS_SIN_POLAR`^2 `r F_THETA_ALPHA`
        [1 - 3`r F_THETA_ALPHA` + 2f^2(\theta, \alpha) ].
  \end{split}                              (\#eq:second-deriv-theta-developed-2)
\end{equation}


### Condition for the point of maximal slope

When $`r F_THETA_ALPHA_DIFF2_THETA` = 0$,
$`r A_COS_SIN_POLAR`^2 `r F_THETA_ALPHA` [1 - 3 `r F_THETA_ALPHA` + 2 `r F_THETA_ALPHA`^2] = 0$.
As this must be true for any value of $\alpha$,
the term $`r A_COS_SIN_POLAR`^2$ is irrelevant.
Thus, there is a root when $`r F_THETA_ALPHA` = 0$,
and two roots when $1 - 3 `r F_THETA_ALPHA` + 2 `r F_THETA_ALPHA`^2 = 0$.

There is one root when $`r F_THETA_ALPHA` = 1$:
$(1 - 3 · 1 + 2 · 1) = (1 - 3 + 2) = 0$.
However, $`r F_THETA_ALPHA` = 1$
when $\theta \rightarrow \infty$.
Also, $`r F_THETA_ALPHA` = 0$ is satisfied when $\theta \rightarrow \infty$
(depending on the value of $`r ALPHA`$,
$`r F_THETA_ALPHA`$ will be equal to 0 or 1).

The other root occurs when $`r F_THETA_ALPHA` = \tfrac{1}{2}$:
$(1 - 3 · 1/2 + 2 · (1/2)^2) = (1 - 1.5 + 0.5) = 0$,
as shown in Equation \@ref(eq:condition-max-slope-theta).
In such case,


\begin{equation}
  \begin{split}
    `r F_THETA_ALPHA_DIFF_THETA` &=
      \frac{1}{2} \left(1 - \frac{1}{2}\right) `r A_COS_SIN_POLAR` \\
      &= \frac{1}{4} `r A_COS_SIN_POLAR`
  \end{split}
\end{equation}


The value of $\theta$ for this maximal slope is then obtained
from \@ref(eq:max-slope-alpha-solution).
Note that, in \@ref(eq:max-slope-alpha-solution),
following the equivalent derivation in \@ref(eq:zeta-first-deriv-solution)
for $`r SIN_ALPHA`$, we get

\begin{equation}
  \begin{split}
  `r ZETA_ALPHA` &= `r FRAC_1_4`
    \left( `r A1_COS_ALPHA_AS_SIN` - `r A2_SIN_ALPHA` \right) \\
  `r ZETA_ALPHA_DIFF_SIN_ALPHA` &=
    - `r FRAC_1_4` \frac{`r SIN_ALPHA`}{`r COS_ALPHA_AS_SIN`} a_1 -
      `r FRAC_1_4` a_2 \\
    `r ZETA_ALPHA_DIFF_SIN_ALPHA` = 0
      & \Leftrightarrow
        - a_1 \frac{`r SIN_ALPHA`}{`r COS_ALPHA_AS_SIN`} - a_2 = 0 \\
      & \Leftrightarrow
        a_1 `r SIN_ALPHA` = - a_2 `r COS_ALPHA_AS_SIN` \\
      & \Leftrightarrow
        a_1^2 `r SIN_SQ_ALPHA` = (- a_2)^2 (1 - `r SIN_SQ_ALPHA`) \\
      & \Leftrightarrow
        (a_1^2 + a_2^2) `r SIN_SQ_ALPHA` = (- a_2)^2 \\
      & \Leftrightarrow
        `r SIN_ALPHA` = `r MINUS_A2_OVER_SQRT_A_SQ`
  \end{split}
\end{equation}


To get to the right part of this expression, the following intermediate steps
have been omitted[^sol_theta_max_slope]:

\begin{equation}
  \begin{split}
    `r LOG_DENOM_MAX_THETA` &= 2 \\
    `r EXP_MAX_THETA` &= 1 \\
    `r LOG_EXPONENT_MAX_THETA` &= 0 \\
    - \frac{a_1_2 + a_2^2}{ `r SQRT_A1_A2_SQUARED` } \theta &= -l \\
    \frac{ \left(`r SQRT_A1_A2_SQUARED` \right)^2 }{ `r SQRT_A1_A2_SQUARED` } \theta &= l \\
    `r SQRT_A1_A2_SQUARED` \theta &= l \\
    \theta &= \frac {l}{`r SQRT_A1_A2_SQUARED`}
  \end{split}
\end{equation}


[^sol_theta_max_slope]: It seems like there could be a mistake,
being the numerator in the left part of \@ref(eq:max-slope-alpha-solution)
$l$ instead of $-l$.
Also, as the exponent in \@ref(eq:max-slope-alpha-solution)
(i.e. inside the parenthesis) seems to be
$`r LOG_EXPONENT_MAX_THETA_CORR`$,
due to the minus sign of $a_2$ in Equation \@ref(eq:model-polar).
If so, the correct result in \@ref(eq:max-slope-alpha-solution) must be
$\tfrac {l`r SQRT_A1_A2_SQUARED`}{(a_1^2 - a_2^2)}$.

\newpage

# About the axis transformation and graphical representation in the MUPP-2PL model

## Original derivation by Mario Luzardo (13-07-2019)

### Transformation of the axes

There are two ways of treating it: geometrically, or as a change of base.


#### Geometrical interpretation of the axis transformation

Following the notation in my dissertation, let

\begin{equation}
  `r THETA_ORTH` = `r T_INVERSE` `r THETA`       (\#eq:orthogonalized-theta-def)
\end{equation}

with $`r THETA` \in V \subset R^D$,
$`r THETA_ORTH`$ the trait vector in the orthogonal space,
and $`r THETA`$ the trait vector in the oblique space.

Regarding $`r SIGMA` = `r T_MATRIX` `r T_MATRIX`'$: This is not correct.
If we are in the context of factor analysis
(where the variables and factors are standardized),
the correlation matrix fulfills the previous relationship,
as can be seen in Harman [-@harman_modern_1970].
`r insert_anchor("assertion-T-root-Sigma")`


**Justification:** Given Equation \@ref(eq:orthogonalized-theta-def),
$`r THETA` = `r T_MATRIX` `r THETA_ORTH`$.
If all the variables are standardized, then

\begin{equation}
  `r R_MATRIX` = `r COV`(`r THETA`, `r THETA`) =
    `r COV`(`r T_MATRIX``r THETA_ORTH`, `r T_MATRIX``r THETA_ORTH`) =
    `r T_MATRIX` `r COV`(`r THETA_ORTH`, `r THETA_ORTH`) `r T_MATRIX`' =
    `r T_MATRIX` `r T_MATRIX`',                         (\#eq:r-matrix-equality)
\end{equation}

because  $`r COV`(`r THETA_ORTH`, `r THETA_ORTH`) = `r ID_MATRIX`$,
as they are orthogonal and have variance 1.

If they are not standardized, but are just orthogonal instead,

\begin{equation}
  `r COV`(`r THETA`, `r THETA`) =
    `r T_MATRIX` `r D_MATRIX` `r T_MATRIX`', \qquad
    `r D_MATRIX` = \begin{pmatrix} 
      s_1^2  & \cdots &      0 \\
      \vdots & \ddots & \vdots \\
      0      & \cdots &  s_d^2 \\
    \end{pmatrix},                           (\#eq:sigma-matrix-equality-non-sd)
\end{equation}

that is, $`r SIGMA` = `r T_MATRIX` `r D_MATRIX` `r T_MATRIX`'$.

Say we are in the context where the orthogonal variables are standardized
(e.g., factor analysis or IRT estimation); then $`r T_MATRIX`$ is a rotation
and, because the distances are invariant to rotations, it is true that
$`r SIGMA` = `r T_MATRIX` `r T_MATRIX`'$.

We see that this is not the case,
because $`r T_MATRIX`$ is a transformation that is *not strictly* a rotation.

Let's see how the transformed parameters are. Considering the MCLM model,

\begin{equation}
  `r P_THETA` = `r LOGISTIC_MCLM` = `r LOGISTIC_MCLM_ORTH`     (\#eq:MCLM-model)
\end{equation}

that is, $(`r A_VECTOR_ORTH`)' = `r A_VECTOR`' `r T_MATRIX`$, or
$`r A_VECTOR_ORTH` = `r T_MATRIX`' `r A_VECTOR`$.

\begin{equation}
  `r MBL` = `r MBL_DEF`                                               (\#eq:MBL)
\end{equation}

(but the expression with $`r SIGMA`$ **instead of** $`r T_MATRIX``r T_MATRIX`'$,
i.e. in equation 3.6 in my dissertation, is not correct).

Now let's see the change of coordinates.
Let $`r COORD_SYSTEM`$ be the original, oblique coordinate system
that will be transformed into the orthogonal coordinate system,
$`r COORD_SYSTEM_ORTH`$[^orth_coords].
In order to this, we consider $`r THETA_1` \equiv `r THETA_1`^\mathrm{o}$
(i.e., it is not transformed),
and we transform $`r THETA_2`$ in $`r THETA_2`^\mathrm{o}$ such that
$`r THETA_2`^\mathrm{o} \perp `r THETA_1`^\mathrm{o}$. Graphically:

[^orth_coords]: Although Mario calls the orthogonal axes
$`r THETA_1`'$ and $`r THETA_2`'$, I think it is more appropriate to use the
notation $`r THETA_1`^\mathrm{o}$ and $`r THETA_2`^\mathrm{o}$,
as it is consistent with the notation used previously.

```{r coord-transform, fig.id="coord-transform", warning=FALSE, fig.cap="Axis transformation."}
GUIDE_SEGMENTS <- tibble(
  x    = c(0, 0, 2, 1.5),
  y    = c(0, 1, 0, 0),
  xend = c(2, 2, 2, 2),
  yend = c(4, 1, 1, 1),
  line = c("solid", "longdash" %>% rep(3))
)

point_labels <- tribble(
  ~x,  ~y, ~show,   ~label,
   0,   0,  FALSE,  '0', ## TODO: = in italics in the equation
   1.5, 0,  FALSE,  'A',
   2,   0,  FALSE,  'B',
   0.5, 1,  FALSE,  'C',
   0,   1,  FALSE,  'D',
   2,   1,  TRUE,   'P'
) %>%
  add_column(
    nudgex = c( 0  %>% rep(3), -.12 %>% rep(3)),
    nudgey = c(-.1 %>% rep(3),  .12 %>% rep(3))
  )

ggplot() +
  geom_segment(
    mapping = aes(x, y, xend = xend, yend = yend, linetype = I(line)),
    data    = GUIDE_SEGMENTS,
    size    = LINE_WIDTH
  ) +
  geom_point(x = 2, y = 1, aes(shape = I(POINT_CHAR))) +
  # geom_text(
  #   data     = point_labels,
  #   mapping  = aes(x, y, label = label),
  #   position = point_labels %$% position_nudge(nudgex, nudgey),
  #   family   = GRAPH_FONT
  # ) +
  annotate(
    geom     = "text",
    x        = point_labels$x + point_labels$nudgex,
    y        = point_labels$y + point_labels$nudgey,
    label    = point_labels$label %>% TeX(italic = TRUE),
    family   = GRAPH_FONT
  ) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = .5, start = pi / 2, end = acos(2 / sqrt(5))),
    size   = ANGLE_WIDTH
  ) +
  annotate(
    geom   = "text",
    label  = c("$\\theta_1$", glue("${ALPHA}$")) %>% TeX(),
    x      = c(1.75, .5),
    y      = c(3.88, .35),
    family = GRAPH_FONT
  ) +
  xlab("$\\theta_1 \\equiv \\theta_1^o$" %>% TeX()) +
  ylab("$\\theta_2^o$" %>% TeX()) +
  scale_x_continuous(limits = c(0, 4), breaks = NULL, oob = oob_keep) +
  scale_y_continuous(limits = c(0, 4), breaks = NULL, oob = oob_keep) +
  coord_fixed(clip = "off", expand = FALSE)
```


We know that $`r COS_ALPHA` = `r RHO_COORD_SYSTEM`$.
Let $P$ be a point
with coordinates $(x, y)$ in the system $`r COORD_SYSTEM`$
and coordinates $(x', y')$ in the system $`r COORD_SYSTEM_ORTH`$.

We have that[^point_notation]

\begin{equation}
  \begin{split}
    &0B = x' \qquad &0D = y', \\
    &0A = x  \qquad &0C = y,  \\
    &0B = 0A + AB.
  \end{split}
\end{equation}

[^point_notation]: Here Mario uses $`r THETA_1`$ and $`r THETA_2`$
instead of $x$ and $y$,
and $`r THETA_1`'$ and $`r THETA_2`'$ instead of $x'$ and $y'$;
however, he has just defined $(x, y)$ and $(x', y')$ as the coordinates of
point $P$ in the oblique and orthogonal reference system respectively.
Therefore, my understanding in that $`r THETA_1`$ should be considered as an
*axis*, and $x$ as a coordinate on that axis and so on,
so e.g., $x$ and $`r THETA_1`$ are semantically different symbols.
Therefore I'm using here $x$, $y$, $x'$ and $y'$ to represent the coordinates.


$x' = x + AP \, `r COS_ALPHA`$,
because $\measuredangle PAB = \alpha$;  
$AP = y$, because $AP = 0C$;  
therefore $\boxed{x' = x + y \, `r COS_ALPHA`}$.

Also, $0D = BP$, i.e.,  
$y' = AP \, `r SIN_ALPHA`$, $\boxed{y' = y \, `r SIN_ALPHA`}$

But $`r COS_ALPHA` = `r RHO_COORD_SYSTEM`$,
and $`r SIN_ALPHA` = `r SIN_ALPHA_COORD_SYSTEM`$.


\begin{equation}
  \begin{split}
    x' &= x + y \, `r RHO_COORD_SYSTEM` \\
    y' &=     y \, `r SIN_ALPHA_COORD_SYSTEM`
  \end{split}
\end{equation}

or, equivalently,

\begin{equation}
  \begin{pmatrix} 
    x' \\
    y' \\
  \end{pmatrix}
    =
    \begin{pmatrix} 
      1 & `r RHO_COORD_SYSTEM` \\
      0 & `r SIN_ALPHA_COORD_SYSTEM` \\
    \end{pmatrix}
    \begin{pmatrix} 
      x \\
      y \\
    \end{pmatrix}.                                        (\#eq:coord-transform)
\end{equation}


This is Equation \@ref(eq:orthogonalized-theta-def)
($`r THETA_ORTH` = `r T_INVERSE` `r THETA`$),
in the notation of my dissertation (Equation 3.3 there).

The previous equation in horizontal vector form is

\begin{equation}
  (x',  y') = (x, y)
    \begin{pmatrix} 
      1                    & 0                    \\
      `r RHO_COORD_SYSTEM` & `r SIN_ALPHA_COORD_SYSTEM` \\
    \end{pmatrix},                             (\#eq:coord-transform-horizontal)
\end{equation}

$`r THETA_ORTH`' = `r THETA`' (`r T_INVERSE`)'$.


#### Change-of-base interpretation of the axis transformation

Another way of putting this is by making a change of base.
The base of the orthogonal system $`r COORD_SYSTEM_ORTH`$
is $`r ORTHONORMAL_BASE`$, i.e., the canonical base.

The base of the oblique system $`r COORD_SYSTEM`$ will be given by the vectors

```{r oblique-base, fig.id="oblique-base", warning=FALSE, fig.cap="Oblique base."}
SLOPE_V2 <- 2

base_vectors <- tibble(
  x     = c(1, 1),
  y     = c(0, SLOPE_V2),
  label = c("$(1, 0)$" %>% TeX(), expression(bold(v)[2])),
  width = c(VECTOR_WIDTH %>% rep(2))
) %>% 
  mutate(
    norm = sqrt(x^2 + y^2),
    across(x:y,  ~ . / norm, .names = "{.col}_norm")
  )

base_vectors %>% ggplot() +
  geom_segment(x = 0, y = 0, xend = 1, yend = SLOPE_V2, size = LINE_WIDTH) +
  geom_segment(
    aes(xend = x_norm, yend = y_norm, size = I(width)),
    x        = 0,
    y        = 0,
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = .5, start = pi / 2, end = x_norm[2]),
    data = base_vectors,
    size = ANGLE_WIDTH
  ) +
  annotate(
    geom   = "text",
    label  = base_vectors$label %>% c(c("$\\theta_2$", "$\\alpha$") %>% TeX()),
    x      = c(.8, .27,  .85, .5),
    y      = c(.1, .75, 1.88, .27),
    family = GRAPH_FONT
  ) +
  xlab(TeX("$\\theta_1 \\equiv \\theta_1'$")) +
  ylab(NULL) +
  scale_x_continuous(limits = c(0, 2), breaks = NULL) +
  scale_y_continuous(limits = c(0, 2), breaks = NULL) +
  coord_fixed(clip = "off", expand = FALSE) +
  theme(axis.line.y = element_blank())
```


$`r V_2_VECTOR`$ is given by the normalization of the vector

\begin{equation}
  (1, \, \tan \alpha) = `r DIRECTOR_VECTOR`.              (\#eq:director-vector)
\end{equation}

Its norm is

\begin{equation}
  \left\| `r DIRECTOR_VECTOR` \right\|^2 = 1 + \frac{1 - \rho^2}{\rho^2} =
    \frac{1}{\rho^2},
\end{equation}

\begin{equation}
  \left\| `r DIRECTOR_VECTOR` \right\| = \frac{1}{\rho};
                                                     (\#eq:director-vector-norm)
\end{equation}


therefore

\begin{equation}
  `r V_2_VECTOR` = \frac{ \left( 1, \tfrac{`r SIN_ALPHA_AS_RHO`}{\rho} \right) }
                        { \tfrac{1}{\rho} }
                 = `r NORM_DIR_VECTOR`.     (\#eq:director-vector-normalization)
\end{equation}

The oblique base is

\begin{equation}
  `r OBLIQUE_BASE`.                                          (\#eq:oblique-base)
\end{equation}


The change of base matrix that we need contains the coordinates of the base
$`r OBLIQUE_BASE`$ in the base $`r ORTHONORMAL_BASE`$, that is,

\begin{equation}
  \begin{split}
    (1, \, 0)                                  &= 1 (1, \, 0) + 0 (0, \, 1) \\
    \left(\rho, \, `r SIN_ALPHA_AS_RHO`\right) &=
      \rho (1, \, 0) + `r SIN_ALPHA_AS_RHO` (0, \, 1).
  \end{split}                            (\#eq:change-of-base-matrix-derivation)
\end{equation}


The resulting matrix is

\begin{equation}
  `r T_INVERSE` = `r T_INVERSE_DEF`.                (\#eq:change-of-base-matrix)
\end{equation}

### Representation of the multidimensional parameters in an oblique space

In order to represent the *MBL* and *MBS* in the oblique axes
we should compute them in the orthogonal space,
as the formulae found by Reckase
[-@reckase_difficulty_1985, -@reckase_discriminating_1991]
are for orthogonal axes.

\begin{equation}
  `r MBL` = `r MBL_DEF_ORTH` \qquad `r MBS` = `r MBS_DEF_ORTH`
                                       (\#eq:multidimensional-params-orthogonal)
\end{equation}


If $`r GAMMA_COMPONENT`$ is the angle in axis $k$
(we do not call it $\alpha$,
as in @reckase_difficulty_1985 and @reckase_discriminating_1991
to avoid confusing it with the angle between
$`r THETA_1`$ and $`r THETA_2`$),

\begin{equation}
  `r DIRECTOR_COSINE` = \frac{`r A_COMPONENT_ORTH`}{`r MBS_DEF_ORTH`}
    \Rightarrow
    `r DIR_COS_VECTOR` = \frac{`r A_VECTOR_ORTH`}{`r MBS_DEF_ORTH`}.
                                                           (\#eq:dir-cos-vector)
\end{equation}

(`r DIR_COS_VECTOR` is the vector of director cosines.)

Given $`r A_VECTOR_ORTH`' = `r A_VECTOR`' `r T_MATRIX`$,

\begin{equation}
  \begin{split}
    `r MBL`            &= `r MBL_DEF` \\
    `r MBS`            &= `r MBS_DEF` \\
    `r DIR_COS_VECTOR` &=
      \frac{`r T_TRANSP_A`}{`r MBS_DEF`} =
      `r DIR_COS_VECTOR_DEF`
  \end{split}                             (\#eq:multidimensional-params-oblique)
\end{equation}

(with $`r GAMMA_VECTOR`$ the cosines expressed as a vertical vector).

```{r multidimensional-components-orthogonal, fig.id="multidimensional-components-orthogonal", warning=FALSE, fig.cap="Multidimensional parameters."}
SLOPE <- .8

POINTS <- tribble(
  ~x, ~y,   ~name,
   1,   .8,  'P',
   2,  1.6,  'Q'
)

angle <- atan(SLOPE)

POINTS %>% ggplot() +
  geom_abline(slope = SLOPE, size = LINE_WIDTH, linetype = "11") +
  geom_point(aes(x, y)) +
  # geom_text(
  #   # aes(x, y, label = substitute(expression(italics(name)), POINTS)),
  #   aes(x, y, label = name %>% TeX(italic = TRUE)),
  #   position = position_nudge(x = .05, y = -.05),
  #   family   = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    x      = POINTS$x + .05,
    y      = POINTS$y - .05,
    label  = POINTS$name %>% TeX(italic = TRUE),
    family = GRAPH_FONT
  ) +
  geom_arc(
    aes(
      x0 = 0,
      y0 = 0,
      r = c(.5, .6),
      start = c(pi / 2, 0),
      end = pi / 2 - angle
    ),
    size   = ANGLE_WIDTH
  ) +
  annotate(
    geom   = "text",
    label  = c("$\\gamma_1'$", "$\\gamma_2'$", "$(MBL_i)$", "$MBS_i$") %>% TeX(),
    x      = c(.55, .29, 1.05, 1.25),
    y      = c(.2, .65,  .65, 1.37),
    family = GRAPH_FONT
  ) +
  xlab(TeX("$\\theta_1^o$")) +
  ylab(TeX("$\\theta_2^o$")) +
  scale_x_continuous(limits = c(0, 2.2), breaks = NULL) +
  scale_y_continuous(limits = c(0, 2),   breaks = NULL) +
  coord_fixed(expand = FALSE)

grid.brackets(576, 656, 1062, 270, lwd = 1, col = "black")
```


We need to find the trasformed parameters in order to represent this
in the oblique axes.
Given $`r THETA` = `r T_MATRIX` `r THETA_ORTH`$[^theta_orth],
by Equation \@ref(eq:orthogonalized-theta-def),
we must transform points $P$ and $Q$ [^point_Q].

[^theta_orth]: Note that Mario uses here the notation
$`r THETA` = `r T_MATRIX` `r THETA`'$,
but he does not mean $`r THETA`$ transposed but a point in the coordinate system
$`r COORD_SYSTEM_ORTH`$, i.e., the orthogonal coordinate system.
This equality comes from Equation \@ref(eq:orthogonalized-theta-def),
$`r THETA_ORTH` = `r T_INVERSE` `r THETA` \Rightarrow `r T_MATRIX` `r THETA_ORTH` = `r T_MATRIX` `r T_INVERSE` `r THETA` \Rightarrow `r T_MATRIX` `r THETA_ORTH` = `r ID_MATRIX` `r THETA` \Rightarrow `r T_MATRIX` `r THETA_ORTH` = `r THETA`$

[^point_Q]: Here Mario calls the points $P$ and $T$,
but I think he later notices that the orthogonalizing matrix is named
$`r T_MATRIX`$ and changes the name of the point to $Q$ in order to avoid
confusion with it.

```{r multidimensional-components-oblique, fig.id="multidimensional-components-oblique", warning=FALSE, fig.cap="Point coordinates in the orthogonal space."}
guide_segments <- POINTS %>%
  slice(1:n() %>% rep(each = 2)) %>%
  mutate(across(x:y, .fns =  ~., .names = "{.col}_0")) %>%
  mutate(x_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(0, x_0)) %>% 
  mutate(y_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(y_0, 0))

POINTS %>% ggplot() +
  geom_abline(slope = SLOPE, size = LINE_WIDTH, linetype = "11") +
  geom_point(aes(x, y)) +
  # geom_text(
  #   aes(x, y, label = name),
  #   position = position_nudge(x = .05, y = -.05),
  #   family   = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    x      = POINTS$x + .05,
    y      = POINTS$y - .05,
    label  = POINTS$name %>% TeX(italic = TRUE),
    family = GRAPH_FONT
  ) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = .5, start = pi / 2, end = pi / 2 - angle),
    size   = ANGLE_WIDTH
  ) +
  annotate(
    geom   = "text",
    label  = c("$\\beta$", 'x', 'y',  'l') %>% TeX(italic = TRUE),
    # label  = expression(beta, italic(x), italic(y), italic(l)),
    x      = c( .55,        1,   -.04, 1.5),
    y      = c( .2,         -.04, .8,  1.25),
    family = GRAPH_FONT
  ) +
  xlab(TeX("$\\theta_1^o$")) +
  ylab(TeX("$\\theta_2^o$")) +
  scale_x_continuous(limits = c(0, 2.2), breaks = NULL, oob = oob_keep) +
  scale_y_continuous(limits = c(0, 2),   breaks = NULL, oob = oob_keep) +
  coord_fixed(expand = FALSE, clip = "off")
```


$P \equiv (x, y) \qquad Q \equiv (x', y')$[^quote_mark]

[^quote_mark]: These $(x', y')$ mean something different than before.
In the previous section, they made reference to the coordinates $(x, y)$
transformed to the orthonormal space.
Here though, both $(x, y)$ and $(x', y')$
are coordinates in the orthonormal space,
but $(x, y)$ are the coordinates of point $P$
and $(x', y')$ are the coordinates of point $Q$.

$(x, y)$, $\beta$[^beta_gamma1_equiv], and $l$[^l_clarification] are known.
A vector in the direction of the line with norm 1 is $`r DIR_VECTOR_NORM`$.

[^beta_gamma1_equiv]: $\beta$ may be called $\gamma_1$ directly;
this equivalence is stated later.

[^l_clarification]: $l$ is the norm of the segment $\overline{PQ}$,
NOT to be mistaken with $l_i$,
the intersection parameter of item $i$.

This comes from the normalization of

\begin{equation}
  `r DIR_VECTOR` = \left(1, `r TAN_BETA_DEF` \right).
\end{equation}

It's (squared) norm is

\begin{equation}
  1 + \frac{\sin^2 \beta}{\cos^2 \beta} = \frac{1}{\cos^2 \beta};
\end{equation}

thus normalizing,

\begin{equation}
  \frac{`r DIR_VECTOR`}{\tfrac{1}{\cos \beta}} = `r DIR_VECTOR_NORM`.
\end{equation}

$Q = P + l \, `r DIR_VECTOR_NORM` = (`r X_COORD_Q`, `r Y_COORD_Q`)$.

Then, the transformed coordinates are

\begin{equation}
  `r T_MATRIX` \begin{pmatrix} x \\ y \\ \end{pmatrix}
                                               (\#eq:point-P-coords-transformed)
\end{equation}

and

\begin{equation}
  `r T_MATRIX` \begin{pmatrix} `r X_COORD_Q` \\ `r Y_COORD_Q` \\ \end{pmatrix}.
                                               (\#eq:point-Q-coords-transformed)
\end{equation}

We know that $P \equiv `r MBL` `r DIR_VECTOR_NORM`$, $l = `r MBS`$,
and $\cos \beta$ is the component of $`r DIR_COS_VECTOR`$
with respect to axis $`r THETA_1`'$.

\begin{equation}
  `r T_MATRIX` P = `r MBL_DEF` `r T_MATRIX` `r DIR_VECTOR_NORM`
                                                      (\#eq:point-P-transformed)
\end{equation}

Let $e' = (0, \dots, 0, 1, 0, \dots, 0)$ be the vector with a 1 in the
component that represents $`r THETA_1`$.
Given the Equations in \@ref(eq:multidimensional-params-oblique),

\begin{equation}
  \begin{split}
    \cos \beta &= \frac{e' `r T_TRANSP_A`}{`r MBS_DEF`} \\
    \sin \beta &= `r SIN_BETA_AS_COS`
  \end{split},                                           (\#eq:cos-sin-beta-def)
\end{equation}

\begin{equation}
  Q \equiv \left[ `r MBL_DEF` - sgn(l_i) `r MBS_DEF` \right]
    `r DIR_VECTOR_NORM_T`,                                        (\#eq:point-Q)
\end{equation}

and[^sign_l_i]`r insert_anchor("fn-sign_l_i")`

\begin{equation}
  `r T_MATRIX` Q = \left[ `r MBL_DEF` - sgn(l_i) `r MBS_DEF` \right]
    `r T_MATRIX` `r DIR_VECTOR_NORM_T`.               (\#eq:point-Q-transformed)
\end{equation}

[^sign_l_i]: I don't understand where $sgn(l_i)$ comes from in
Equations \@ref(eq:point-Q) and \@ref(eq:point-Q-transformed).
As I understand it, the direction should be given, in any case,
by the sign of the component on the axis, that is, $sgn(a_{i1})$.
However, $\sin \beta$ may (or should?) already imply the sign here.


From Equation \@ref(eq:change-of-base-matrix), we have

\begin{equation}
  `r T_INVERSE` = `r T_INVERSE_DEF`;
\end{equation}

\begin{equation}
  \det(`r T_INVERSE`) = `r SIN_ALPHA_AS_RHO`,
\end{equation}

\begin{equation}
  `r T_MATRIX` = \frac{
    \begin{pmatrix}
      `r SIN_ALPHA_AS_RHO` & 0 \\
      -\rho                & 1
    \end{pmatrix}'
  }
  {`r SIN_ALPHA_AS_RHO`} =
    \frac{
      \begin{pmatrix}
        `r SIN_ALPHA_AS_RHO` & -\rho \\
        0                    & 1
      \end{pmatrix}
    }
    {`r SIN_ALPHA_AS_RHO`} = `r T_MATRIX_DEF`.        (\#eq:T-matrix-definition)
\end{equation}

We check that $`r T_MATRIX` `r T_INVERSE` = `r ID_MATRIX`$:

\begin{equation}
  `r T_MATRIX` `r T_INVERSE` = `r T_MATRIX_DEF` `r T_INVERSE_DEF` =
    \begin{pmatrix}
      1 & 0 \\
      0 & 1
    \end{pmatrix}.
\end{equation}


However, $`r T_MATRIX` `r T_MATRIX`'$ is not equal to $`r SIGMA`$:
[^T_squared_clarification]

[^T_squared_clarification]: But $`r T_MATRIX` `r T_MATRIX`' = `r SIGMA`^{-1}$,
as we will see later on.

\begin{equation}
  \begin{split}
    `r T_MATRIX` `r T_MATRIX`' &= `r T_MATRIX_DEF`
      \begin{pmatrix}
        1                                   & 0 \\
        -\tfrac{\rho}{`r SIN_ALPHA_AS_RHO`} &
          \tfrac{1}{`r SIN_ALPHA_AS_RHO`}
      \end{pmatrix} =
      \begin{pmatrix}
        1 + \frac{\rho^2}{1 - \rho^2} & \frac{-\rho}{1 - \rho^2} \\
            \frac{-\rho}{1 - \rho^2}  &     \frac{1}{1 - \rho^2}
      \end{pmatrix} \\
      &=
      \begin{pmatrix}
            \frac{1}{1 - \rho^2} & \frac{-\rho}{1 - \rho^2} \\
        \frac{-\rho}{1 - \rho^2} &     \frac{1}{1 - \rho^2}
      \end{pmatrix}                         (\#eq:T-T-transposed-matrix-product)
  \end{split}
\end{equation}

#### Example of graphical representation

Let's assume an item $a_1$ in a bidimensional latent space where
$\rho = `r RHO`$, with parameters $a_{1_1} = `r A_1_1`$, $a_{1_2} = `r A_1_2`$,
and $l_1 = `r L_1`$:

\begin{equation}
  `r A_1_VECTOR`' = `r A_1_VECTOR_DEF_T`
\end{equation}

\begin{equation}
  `r T_MATRIX` = `r T_MATRIX_DEF_EXAMPLE`
\end{equation}

\begin{equation}
  `r A_1_VECTOR_ORTH`' = `r A_1_VECTOR_DEF_T` \begin{pmatrix}
    1 & `r T_VALUE[1, 2]` \\
    0 & `r T_VALUE[2, 2]`
  \end{pmatrix}
\end{equation}

\begin{equation}
  `r T_MATRIX` `r T_MATRIX`' = `r T_SQ`
\end{equation}

\begin{equation}
  \begin{split}
    `r PROD_SQ_A_1_T` &= `r A_1_VECTOR_DEF_T` `r T_SQ` `r A_1_VEC_DEF_VERT` \\
                      &= \left(
                        \tfrac{8}{3} + \tfrac{2}{6}, \,
                        -\tfrac{4}{3} - \tfrac{4}{6}
                      \right)
                           `r A_1_VEC_DEF_FRAC` \\
                      &= (3, \, -2) `r A_1_VEC_DEF_FRAC` =
                        `r A_1_ORTH_SQ_VALUE`
  \end{split}
\end{equation}

\begin{equation}
  `r MBL_1` = \frac{`r L_1`}{\sqrt{`r PROD_SQ_A_1_T`}} =
    -\frac{`r L_1`}{\sqrt{`r A_1_ORTH_SQ_VALUE`}} = `r MBL_1_VALUE`.
\end{equation}


We need to find the direction

\begin{equation}
  \cos \beta = \frac{e' `r PROD_T_A_1`}{\|`r PROD_T_A_1`\|} =
    \frac{(1, \, 0) `r PROD_T_A_1`}{\sqrt{`r A_1_ORTH_SQ_VALUE`}}.
\end{equation}

($e'$ is the direction given by $\theta_1 \equiv \theta_1'$.)


In our case,

\begin{equation}
  `r T_MATRIX`' =
    `r T_MATRIX_TRANSP_DEF` =
    \begin{pmatrix}
      1                                             & 0 \\
      \frac{-\tfrac{1}{2}}{\sqrt{1 - \tfrac{1}{4}}} &
        \frac{1}{\sqrt{1 - \tfrac{1}{4}}}
    \end{pmatrix} =
    `r T_MATRIX_TRANSP_FRAC_DEF`.
\end{equation}

Thus,

\begin{equation}
  `r PROD_T_A_1` = `r T_MATRIX_TRANSP_FRAC_DEF` `r A_1_VEC_DEF_FRAC` =
    \begin{pmatrix}
      2 \\
      - \frac{2}{\sqrt{3}} - \frac{1}{\sqrt{3}}
    \end{pmatrix} =
    \begin{pmatrix}
      2 \\
      - \frac{3}{\sqrt{3}}
    \end{pmatrix} =
    \begin{pmatrix}
      2 \\
      - \sqrt{3}
    \end{pmatrix},
\end{equation}


\begin{equation}
  e' `r PROD_T_A_1` = (1, \, 0)
    \begin{pmatrix}
      2 \\
      - \sqrt{3}
    \end{pmatrix} =
    2,
\end{equation}

\begin{equation}
  \cos \beta = \frac{2}{\sqrt{7}} = `r COS_BETA_VALUE` \Rightarrow
    \beta \approx `r number(BETA_VALUE_DEG, 1e-2)`º.
\end{equation}

```{r graphical-representation-example-angles, fig.id="graphical-representation-example-angles", fig.cap="Director angles."}
angles <- tibble(init = c(0, BETA_VALUE, pi / 2, BETA_VALUE + pi, 3/2 * pi)) %>%
  mutate(end = init %>% lead(1)) %>%
  slice(-n()) %>%
  mutate(across(.fns = ~pi / 2 - ., .names = "{.col}_alt")) %>%
  add_column(rad = c(.5, .9, .7, .5)) %>%
  rowwise() %>%
  mutate(
    angle       = (end - init) / pi * 180,
    angle_label = angle %>% number(1e-2, suffix = "º"),
    label_angle = mean(c_across(init:end)),
    label_rad   = rad + .3,
    label_x     = cos(label_angle) * label_rad,
    label_y     = sin(label_angle) * label_rad
  ) %>%
  ungroup()

angles %>% ggplot() +
  geom_abline(slope = BETA_VALUE %>% tan()) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = rad, start = init_alt, end = end_alt),
    size   = ANGLE_WIDTH
  ) +
  geom_text(
    aes(label_x, label_y, label = angle_label),
    family   = GRAPH_FONT
  ) +
  annotate(
    geom   = "text",
    label  = "direction",
    x      = 1.8,
    y      = 1.2,
    family = GRAPH_FONT
  ) +
  scale_x_continuous(
    limits = c(-2, 2),
    breaks = 0,
    labels = NULL,
    name   = NULL
  ) +
  scale_y_continuous(
    limits = c(-2, 2),
    breaks = 0,
    labels = NULL,
    name   = NULL
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme(
    axis.line        = element_blank(),
    axis.ticks       = element_blank(),
    panel.grid.major = element_line(color = "black", size = LINE_WIDTH)
  )
```


$\sin \beta = \sqrt{1 - \tfrac{4}{7}} = \sqrt{\tfrac{3}{7}} \approx `r sqrt(3/7)`$
[^sine_neg]`r insert_anchor("fn-sine_neg")`

[^sine_neg]: I think there is a mistake here, as the sine function should
be negative here, i.e., $-`r SIN_ALPHA_AS_RHO`$ in this case.
I think this because the coordinate $a_{1_2}$ is negative
($a_{1_2} = `r A_1_2`$), and therefore the vector should be pointing towards
a direction in the fourth quadrant (down-right) but,
as we can see in Figure
\@ref(fig:graphical-representation-example-angles), this is not the case.
This makes me think that the sign of $a_{1_2}$ must be considered somehow in
computing the coordinates in this case.

Let's plot $P$:

```{r graphical-representation-example-point-P, fig.id="graphical-representation-example-point-P", fig.cap="Origin of the item vector."}
angle_dir <- angles %>% slice(1) %>%
  mutate(
    label_rad = .6,
    label_x   = cos(label_angle) * label_rad,
    label_y   = sin(label_angle) * label_rad
  )
point_P <- tibble(coord = c('x', 'y'), value = A_1_START_COORDS) %>%
  pivot_wider(names_from = coord)

guide_segments <- point_P %>%
  slice(1 %>% rep(2)) %>%
  mutate(across(x:y, .fns =  ~., .names = "{.col}_0")) %>%
  mutate(x_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(0, x_0)) %>% 
  mutate(y_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(y_0, 0))


angle_dir %>% ggplot() +
  geom_abline(slope = tan(BETA_VALUE)) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = rad, start = init_alt, end = end_alt),
    size = ANGLE_WIDTH
  ) +
  geom_text(
    aes(label_x, label_y, label = angle_label),
    family   = GRAPH_FONT
  ) +
  geom_point(aes(x, y), data = point_P) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  annotate(
    geom   = "text",
    label  = MBL_1_VALUE %>% number(1e-4),
    x      = -.18,
    y      = -.07,
    family = GRAPH_FONT
  ) +
  scale_x_continuous(
    limits = c(-.65, .65),
    breaks = 0,
    labels = NULL,
    name   = NULL
  ) +
  scale_y_continuous(
    limits = c(-.65, .65),
    breaks = 0,
    labels = NULL,
    name = NULL
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme(
    axis.line        = element_blank(),
    axis.ticks       = element_blank(),
    panel.grid.major = element_line(color = "black", size = LINE_WIDTH)
  )
```


\begin{equation}
  P' \equiv `r MBL_1_VALUE`
    \left( \tfrac{2}{\sqrt{7}}, \, \sqrt{\tfrac{3}{7}} \right) =
    (`r A_1_START_COORDS`)
\end{equation}


$Q$ has the form[^point_transposed]

\begin{equation}
  Q' \equiv \left[ `r MBL_DEF` - sgn(l_i) `r MBS_DEF` \right]
    `r DIR_VECTOR_NORM`
\end{equation}

as given by Equation \@ref(eq:point-Q).

\begin{equation}
  Q' \equiv \left[ -\frac{`r L_1`}{\sqrt{`r A_1_ORTH_SQ_VALUE`}} -
    `r A_1_ORTH_SQ_VALUE` \right]
    \left(
      \tfrac{2}{\sqrt{`r A_1_ORTH_SQ_VALUE`}},
      \sqrt{\tfrac{3}{`r A_1_ORTH_SQ_VALUE`}}
    \right) =
    (`r A_1_END_COORDS`)
\end{equation}

[^point_transposed]: I use the notation $P'$ and $Q'$ here,
as we are representing all points as vertical vectors,
but it makes no difference otherwise with Mario's notation ($P$ and $Q$),
given the term in square brackets is a scalar
(so transposing these vectors makes no difference in the result).

```{r graphical-representation-example-vector, fig.id="graphical-representation-example-vector", fig.cap="Complete item vector in the orthogonal space.", warning=FALSE}
angle_dir <- angles %>% slice(1) %>%
  mutate(
    rad       = .3,
    label_rad = .6,
    label_x   = cos(label_angle) * label_rad,
    label_y   = sin(label_angle) * label_rad
  )

points <- tibble(
  coord = c('x', 'y') %>% rep(2),
  value = c(A_1_START_COORDS, A_1_END_COORDS),
  point = c('P', 'Q') %>% rep(each = 2)
) %>%
  pivot_wider(id_cols = point, names_from = coord)

guide_segments <- points %>%
  slice(2 %>% rep(2)) %>%
  mutate(across(x:y, .fns =  ~., .names = "{.col}_0")) %>%
  mutate(x_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(0, x_0)) %>% 
  mutate(y_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(y_0, 0))

item_vector <- points %>% pivot_wider(names_from = point, values_from = x:y)

angle_dir %>% ggplot() +
  geom_abline(slope = tan(BETA_VALUE)) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = rad, start = init_alt, end = end_alt),
    size = ANGLE_WIDTH
  ) +
  geom_text(
    aes(label_x, label_y, label = angle_label),
    family   = GRAPH_FONT
  ) +
  geom_point(aes(x, y), data = points) +
  # geom_text(
  #   aes(x, y, label = point),
  #   data   = points,
  #   position = position_nudge(y = -.2),
  #   family = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    x      = points$x,
    y      = points$y - .2,
    label  = points$point %>% TeX(italic = TRUE),
    family = GRAPH_FONT
  ) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  geom_segment(
    aes(x_P, y_P, xend = x_Q, yend = y_Q, size = I(VECTOR_WIDTH)),
    data     = item_vector,
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  scale_x_continuous(
    limits = c(-3, 1),
    breaks = -3:-1,
    minor_breaks = 0,
    name   = NULL
  ) +
  scale_y_continuous(
    limits = c(-3, 1),
    breaks = -3:-1,
    minor_breaks = 0,
    name   = NULL
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme(
    axis.line        = element_blank(),
    panel.grid.major = element_line(
      color    = "black",
      size     = LINE_WIDTH,
      linetype = "17"
    ),
    panel.grid.minor = element_line(color = "black", size = LINE_WIDTH)
  )
```


What we are interested in is the plot in the oblique plane:

\begin{equation}
  `r T_MATRIX` P = \begin{pmatrix}
    1 & `r T_VALUE[1, 2]` \\
    0 & `r T_VALUE[2, 2]`
  \end{pmatrix}
  \begin{pmatrix}
    `r A_1_START_COORDS[1]` \\
    `r A_1_START_COORDS[2]`
  \end{pmatrix} =
  \begin{pmatrix}
    `r A_1_START_COORDS_OBLIQUE[1]` \\
    `r A_1_START_COORDS_OBLIQUE[2]`
  \end{pmatrix}
\end{equation}

\begin{equation}
  `r T_MATRIX` Q = \begin{pmatrix}
    1 & `r T_VALUE[1, 2]` \\
    0 & `r T_VALUE[2, 2]`
  \end{pmatrix}
  \begin{pmatrix}
    `r A_1_END_COORDS[1]` \\
    `r A_1_END_COORDS[2]`
  \end{pmatrix} =
  \begin{pmatrix}
    `r A_1_END_COORDS_OBLIQUE[1]` \\
    `r A_1_END_COORDS_OBLIQUE[2]`
  \end{pmatrix}
\end{equation}


Given $\rho = `r RHO`$, the angle in $`r THETA_1`$ and $`r THETA_2`$ is
$`r RHO_ARC`$º[^rot_matrix].

[^rot_matrix]: As we will see later on, following the procedure outlined by
Mario gives an incorrect result, where the vector is actually "rotated"
counterclockwise instead of clockwise,
as would be expected and shown in this plot.
The reason, as we will see, is that the transformation must be done by
pre-multiplying by $`r T_MATRIX`'$.
In this plot however, for reasons I do not fully understand yet,
I had to pre-multiply by $`r T_INVERSE`$ instead of $`r T_MATRIX`'$
in order to obtain Mario's plot.


```{r graphical-representation-example-vector-oblique, include=FALSE}
## This chunk follows exactly the method explained by Mario, but it
##   does not work as expected.

points_obl <- tibble(
  coord = c('x', 'y') %>% rep(2),
  value = c(A_1_START_COORDS_OBLIQUE, A_1_END_COORDS_OBLIQUE),
  point = c('P', 'Q') %>% rep(each = 2)
) %>%
  pivot_wider(id_cols = point, names_from = coord) %>%
  mutate(point_label = glue("{T_MATRIX}{point} = {point}_{{oblique}}"))

guide_segments_obl <- guide_segments %>%
  add_column(name = c("H_spike", "V_spike")) %>%
  pivot_longer(cols = where(is.numeric), names_to = "coord") %>%
  mutate(pt = coord %>% str_detect(., "_0") %>% if_else("Q", "axis")) %>%
  group_by(name, pt) %>%
  mutate(value_obl = drop(T_VALUE %*% value)) %>%
  ungroup() %>%
  pivot_wider(id_cols = name, names_from = coord, values_from = value_obl)
  
item_vector_obl <- points_obl %>%
  select(-point_label) %>% 
  pivot_wider(names_from = point, values_from = x:y)

ggplot() +
  geom_abline(slope = tan(RHO_ARC_RAD), size = LINE_WIDTH) +
  geom_hline(yintercept = 0, size = LINE_WIDTH) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = .3, start = pi / 2, end = pi / 2 - RHO_ARC_RAD),
    size = ANGLE_WIDTH
  ) +
  geom_text(
    aes(x = .4, y = .2),
    label  = RHO_ARC %>% number(suffix = 'º'),
    family = GRAPH_FONT
  ) +
  geom_point(aes(x, y), data = points_obl) +
  # geom_text(
  #   aes(x, y, label = point_label),
  #   data     = points_obl,
  #   position = position_nudge(y = -.2),
  #   family   = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    label  = points_obl$point_label %>% TeX(italic = TRUE),
    x      = points_obl$x + .5,
    y      = points_obl$y - .2,
    family = GRAPH_FONT
  ) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments_obl,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  geom_segment(
    aes(x_P, y_P, xend = x_Q, yend = y_Q, size = I(VECTOR_WIDTH)),
    data     = item_vector_obl,
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  scale_x_continuous(
    limits = c(-3, 1),
    breaks = 0,
    labels = NULL,
    name   = NULL,
    oob = oob_keep
  ) +
  scale_y_continuous(
    limits = c(-3, 1),
    breaks = 0,
    labels = NULL,
    name   = NULL,
    oob = oob_keep
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme(
    axis.line        = element_blank(),
    axis.ticks       = element_blank(),
    panel.grid.major = element_blank()
  )
```


```{r graphical-representation-example-vector-oblique-alt, fig.id="graphical-representation-example-vector-oblique-alt", warning=FALSE, fig.cap="Complete item vector in the oblique space."}
## This chunk replicates the previous one, but uses the inverse of the T
##   matrix (as defined by Mario) as the coordinate transformation.

A_1_START_COORDS_OBLIQUE_ALT <- T_INV_VAL %*% A_1_START_COORDS
A_1_END_COORDS_OBLIQUE_ALT   <- T_INV_VAL %*% A_1_END_COORDS


points_obl <- tibble(
  coord = c('x', 'y') %>% rep(2),
  value = c(A_1_START_COORDS_OBLIQUE_ALT, A_1_END_COORDS_OBLIQUE_ALT),
  point = c('P', 'Q') %>% rep(each = 2)
) %>%
  pivot_wider(id_cols = point, names_from = coord) %>%
  mutate(point_label = glue("{T_MATRIX}{point} = {point}_{{oblique}}"))

guide_segments_obl <- guide_segments %>%
  add_column(name = c("H_spike", "V_spike")) %>%
  pivot_longer(cols = where(is.numeric), names_to = "coord") %>%
  mutate(pt = coord %>% str_detect(., "_0") %>% if_else("Q", "axis")) %>%
  group_by(name, pt) %>%
  mutate(value_obl = drop(T_INV_VAL %*% value)) %>%
  ungroup() %>%
  pivot_wider(id_cols = name, names_from = coord, values_from = value_obl)
  
item_vector_obl <- points_obl %>%
  select(-point_label) %>%
  pivot_wider(names_from = point, values_from = x:y)

ggplot() +
  geom_abline(slope = tan(RHO_ARC_RAD), size = LINE_WIDTH) +
  geom_abline(
    slope     = tan(RHO_ARC_RAD),
    intercept = -tan(RHO_ARC_RAD) * (-5:2),
    size      = LINE_WIDTH,
    linetype  = "17"
  ) +
  geom_hline(yintercept = 0, size = LINE_WIDTH) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = .3, start = pi / 2, end = pi / 2 - RHO_ARC_RAD),
    size = ANGLE_WIDTH
  ) +
  geom_text(
    aes(x = .45, y = .22),
    label  = RHO_ARC %>% number(suffix = 'º'),
    family = GRAPH_FONT
  ) +
  geom_point(aes(x, y), data = points_obl) +
  # geom_text(
  #   aes(x, y, label = point_label),
  #   data     = points_obl,
  #   position = position_nudge(y = -.2),
  #   family   = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    label  = points_obl$point_label %>% TeX(italic = TRUE),
    x      = points_obl$x + .5,
    y      = points_obl$y - .2,
    family = GRAPH_FONT
  ) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments_obl,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  geom_segment(
    aes(x_P, y_P, xend = x_Q, yend = y_Q, size = I(VECTOR_WIDTH)),
    data     = item_vector_obl,
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  scale_x_continuous(
    limits       = c(-4, 1),
    breaks       = (-2:2) - 3 / tan(RHO_ARC_RAD),
    labels       = -2:2,
    minor_breaks = NULL,
    name         = NULL,
    oob          = oob_keep
  ) +
  scale_y_continuous(
    limits       = c(-3, 1),
    breaks       = -3:1 * cos(RHO),
    labels       = function(x) x / cos(RHO),
    minor_breaks = 0,
    name         = NULL,
    oob          = oob_keep
  ) +
  coord_fixed(expand = FALSE, clip = "on") +
  theme(
    axis.line          = element_blank(),
    panel.grid.major.y = element_line(
      color    = "black",
      size     = LINE_WIDTH,
      linetype = "17"
    )
  )
```


## Highlights and comments

### About the transformation matrix $`r T_MATRIX`$

Mario
[states that my assertion that $`r SIGMA` = `r T_MATRIX` `r T_MATRIX`'$ is not correct](#assertion-T-root-Sigma)
(see Equations \@ref(eq:r-matrix-equality) and
\@ref(eq:sigma-matrix-equality-non-sd)).
This formula is the definition of a square root matrix [@harman_modern_1970];
that is, $`r T_MATRIX`$ is a square root matrix of $`r SIGMA`$ if they fulfill
that equality (which is implicit in Equation 3.6 in my dissertation).
However, a transformation matrix obtained by the Gram-Schmidt method
*orthogonalizes* the axes, but does not *normalize* (i.e., standardize) them.
Therefore, if
$`r T_MATRIX`$ is a square root matrix of $`r SIGMA`$ then it should be called
an *orthonormalizing* matrix instead, but this is not the same as the
transformation matrix obtained by the Gram-Schmidt method
(or any other orthogonalizing method).
Conversely, if $`r T_MATRIX`$ is an orthogonalizing matrix,
then it is not necessarily a square root matrix of $`r SIGMA`$, as Mario says.
(And, as he adds, this would only be true if $`r SIGMA` = `r R_MATRIX`$.)

In order to generalize these assertions, we may define the following:

Let $\mathbf{N}$ be an orthogonalizing matrix, obtained by the Gram-Schmidt
(or any other) method.
Then,
$`r THETA`^\mathbf{p} = \mathbf{N}^{-1} `r THETA`$ is the trait vector in an
orthogonal space such that
$Cov(`r THETA`^\mathbf{p}, `r THETA`^\mathbf{p}) = \mathbf{D}$.
Let also $\mathbf{S}$ be a scaling matrix,
such that $\mathbf{S} \mathbf{S}' = \mathbf{D}$,
with $\mathbf{D}$ a diagonal matrix.
Then, $`r THETA_ORTH` = \mathbf{S}^{-1} `r THETA`^\mathbf{p}$
is the trait vector in the *orthonormal* space, such that
$Cov(`r THETA_ORTH`, `r THETA_ORTH`) = `r ID_MATRIX`$.
Then, we can define the transformation matrix
$`r T_MATRIX`  = \mathbf{N} \mathbf{S}$ such that
$`r THETA_ORTH` = \mathbf{S}^{-1} `r THETA`^\mathbf{p} = \mathbf{S}^{-1} \mathbf{N}^{-1} `r THETA` = (\mathbf{N} \mathbf{S})^{-1} `r THETA` =  `r T_INVERSE` `r THETA`$.
Given this, $`r T_MATRIX`$ would be a square root matrix of
$`r SIGMA`$, i.e., $`r T_MATRIX` `r T_MATRIX`' = `r SIGMA`$.


### About the product $`r T_MATRIX` `r T_MATRIX`$' {#matrix-squared}

Equation \@ref(eq:T-T-transposed-matrix-product) seems to contradict Equation
\@ref(eq:r-matrix-equality). How is this possible?
Note that if $`r T_MATRIX`$ is an orthogonalizing matrix,
we have seen that it is *not necessarily* a square root matrix of $`r SIGMA`$.
It will be if $`r T_MATRIX`$ is an *orthonormalizing* matrix, as seen before.
However, it should be *necessarily* a square root matrix of $`r R_MATRIX`$.

Equation \@ref(eq:r-matrix-equality) though shows that $`r T_MATRIX`$ is a
square root matrix of $`r R_INVERSE`$ instead,
as $`r T_MATRIX` `r T_MATRIX`' = `r R_INVERSE`$.
We show this by computing the inverse of $`r T_MATRIX` `r T_MATRIX`'$.

\begin{equation}
  \det(`r T_MATRIX` `r T_MATRIX`') =
    \frac{1}{(1 - \rho^2)^2} - \frac{\rho^2}{(1 - \rho^2)^2} =
    \frac{1 - \rho^2}{(1 - \rho^2)^2} =
    \frac{1}{1 - \rho^2}
\end{equation}

\begin{equation}
  (`r T_MATRIX` `r T_MATRIX`')^{-1} = \frac{
    \begin{pmatrix}
         \tfrac{1}{1 - \rho^2} & \tfrac{\rho}{1 - \rho^2} \\
      \tfrac{\rho}{1 - \rho^2} &    \tfrac{1}{1 - \rho^2}
    \end{pmatrix}
  }{\tfrac{1}{1 - \rho^2}} = \begin{pmatrix}
       1 & \rho \\
    \rho &    1
  \end{pmatrix} = `r R_MATRIX`
\end{equation}

Why this result?
It is not clear to me by now, but the explanation may be that the item
parameters do not belong to the same space as the trait parameters and should
not be represented in that same space.
This result appears in Zhang & Stout [-@zhang_theoretical_1999]:
"Note that although both the latent space and the test space
are *d*-dimensional Euclidean spaces,
mathematically they are different spaces because the inner products
in those two spaces are different" (p. 221).
It is worth considering this reference before proceeding.
However, that seems to contradict Reckase and McKinley
[-@reckase_difficulty_1985; -@reckase_discriminating_1991],
who (apparently) define the multidimensional parameters
in the latent trait space.
(This seems to make sense as well,
as the item features give a sense of how the item "behaves"
in relationship to the variation of the measured latent traits.)
Up to now, I have not found the correct solution to this issue.


### About the graphical representation in an oblique space

For what I can say, including the sign of $l_i$ in Equations
\@ref(eq:point-Q) and \@ref(eq:point-Q-transformed) must be wrong.
Point $Q$ is the sum of two vectors: One representing the *difficulty*
parameter (given by point $P$),
and another one representing the *discrimination* parameter,
represented by the distance
$l \equiv \overline{PQ}$
and the direction given by $`r GAMMA_VECTOR`$.
The two terms in the square brackets in
\@ref(eq:point-Q) and \@ref(eq:point-Q-transformed) correspond to the point
$Q$ and the distance $l$, respectively;
$l_i$ is only involved in computing the *diffculty*,
and thus in representing $P$.
Therefore, the sign of $l_i$ should not be involved in computing
the second term in the square brackets.

Also, there is the issue that applying the $`r T_MATRIX`$ transformation
leads to an incorrect graphical representation in the oblique plane.
Following Mario's example,
when we compute the coordinates in the oblique plane by
pre-multiplying by $`r T_MATRIX`$, the following plot results:

```{r graphical-representation-example-vector-oblique, fig.id="graphical-representation-example-vector-oblique", warning=FALSE, fig.cap=glue("Item vector in the oblique space, applying the ${T_MATRIX}$ matrix transformation.")}
```


Here, the axis line and angle annotation have been added by hand
to represent the correlated axes.
However, the vector and the spikes of the $Q$ point
have been computed by applying the transformation given in Equation
\@ref(eq:point-Q-transformed).
This shows how this transformation rotates the angle in the opposite direction
as expected.
That is, the transformation must correspond to a correlation of `r -RHO`
instead of `r RHO`.
On the other hand,
by computing the inverse of this $`r T_MATRIX`$ and pre-multiplying by it
I arrived at the graphical representation in Figure
\@ref(fig:graphical-representation-example-vector-oblique-alt),
which corresponds to Mario's example.

Given the above, my initial guess woud be that these two equations
should actually be

\begin{equation}
  Q \equiv \left[ `r MBL_DEF` + `r MBS_DEF` \right]
    `r DIR_VECTOR_NORM_T`,                              (\#eq:point-Q-corrected)
\end{equation}

(i.e., dropping $- sgn(l_i)$ altogether), as follows from
\@ref(eq:point-Q-coords-transformed)
(see also [this footnote](#fn-sign_l_i)),
and

\begin{equation}
  `r T_INVERSE` Q = \left[ `r MBL_DEF` + `r MBS_DEF` \right]
    `r T_INVERSE` `r DIR_VECTOR_NORM_T`.    (\#eq:point-Q-transformed-corrected)
\end{equation}

(i.e., changing $`r T_MATRIX`$ by $`r T_INVERSE`$).
There is the problem though of whether $`r T_MATRIX`$ is properly defined,
or we are defining in Equations \@ref(eq:coord-transform-horizontal) and
\@ref(eq:change-of-base-matrix) what should actually be called $`r T_MATRIX`$,
as discussed in section \@ref(matrix-squared) above.
If the latter is true, then $`r T_INVERSE`$ should actually be defined
by Equation \@ref(eq:T-matrix-definition).
I think this has yet to be resolved, but in fact the representation according to
Mario's derivations is obtained by pre-multiplying by $`r T_MATRIX`'$
instead of $`r T_INVERSE`$, as we will see later on.


### About the graphical representation example

Regarding the example, [we have already seen in this footnote](#fn-sine_neg)
that, intuitively, it does not seem to be correct:
The graphical representation of the vector should be in the fourth
quadrant, given the signs of the scale parameters.
Also, the oblique axes should have the effect of "shortening" the vector norm
(i.e. length), instead of making it longer.
However, this latter effect is probably due to
being represented in the third quadrant
(because the transformation in the fourth quadrant,
i.e., direction "south-east" or "down-right",
will most likely have this shortening effect).

To my understanding, when we compute the direction given by the angles betweeen
the item vector and the axes, it is important to take into account the
sign of these angles.
Thus, in the example, it should be noted that

\begin{equation}
  \cos \beta = \frac{2}{\sqrt{7}} = `r COS_BETA_VALUE` \Rightarrow
    \beta \approx \pm `r number(BETA_VALUE_DEG, 1e-2)`º,
\end{equation}

i.e., both positive and negative angles with the same absolute value are
valid solutions.
Then, when we make $\sin \beta = `r SIN_BETA_AS_COS`$, we are also disregarding
the sign of $a_{1_2}$ in the computation.
Starting from the definition of $`r DIR_COS_VECTOR`$
in Equations \@ref(eq:multidimensional-params-oblique)
(and noting that these director cosines are given in the orthogonal space)


\begin{equation}
  \sin \beta = \cos \gamma_{i2} = \frac{e' `r PROD_T_A_1`}{\|`r PROD_T_A_1`\|}
\end{equation}

with $e' = (0, \, 1)$, that is


\begin{equation}
    \sin \beta = \frac{(0, \, 1) `r PROD_T_A_1`}{\sqrt{`r A_1_ORTH_SQ_VALUE`}}
\end{equation}

\begin{equation}
  e' `r PROD_T_A_1` = (0, \, 1)
    \begin{pmatrix}
      2 \\
      - \sqrt{3}
    \end{pmatrix} =
      - \sqrt{3},
\end{equation}

\begin{equation}
  \sin \beta = - \sqrt{\frac{3}{7}} = `r SIN_BETA_VALUE_CORR` \Rightarrow
    \beta \approx
    \{
      - `r number(BETA_VALUE_DEG, 1e-2)`º,
      180º + `r number(BETA_VALUE_DEG, 1e-2)`º
    \}=
    \{
      - `r number(BETA_VALUE_DEG, 1e-2)`º,
      `r number(180 + BETA_VALUE_DEG, 1e-2)`º
    \}.
\end{equation}


Therefore, the common (valid) solution is -`r number(BETA_VALUE_DEG, 1e-2)`
and not `r number(BETA_VALUE_DEG, 1e-2)`.
This also converges with the intuitive idea about the direction of the item
I expressed in the first paragraph.

As a result, the coordinates of $P$ and $Q$ would be given by

\begin{equation}
  P' \equiv `r MBL_1_VALUE`
    \left( \tfrac{2}{\sqrt{7}}, \, -\sqrt{\tfrac{3}{7}} \right) =
    (`r A_1_START_COORDS_CORR`)
\end{equation}


and

\begin{equation}
  Q' \equiv \left[ -\frac{`r L_1`}{\sqrt{`r A_1_ORTH_SQ_VALUE`}} -
    `r A_1_ORTH_SQ_VALUE` \right]
    \left(
      \tfrac{2}{\sqrt{`r A_1_ORTH_SQ_VALUE`}},
      - \sqrt{\tfrac{3}{`r A_1_ORTH_SQ_VALUE`}}
    \right) =
    (`r A_1_END_COORDS_CORR`).
\end{equation}


```{r graphical-representation-example-vector-correct, fig.id="graphical-representation-example-vector-correct", fig.cap=glue("Item vector in the orthogonal space, with corrected director angles."), warning=FALSE}
angle <- tibble(init = c(0, -BETA_VALUE)) %>%
  mutate(end = init %>% lead(1)) %>%
  slice(-n()) %>%
  mutate(across(.fns = ~pi / 2 - ., .names = "{.col}_alt")) %>%
  add_column(rad = .5) %>%
  rowwise() %>%
  mutate(
    angle       = (end - init) / pi * 180,
    angle_label = angle %>% number(1e-2, suffix = "º"),
    label_angle = mean(c_across(init:end)),
    label_rad   = rad + .3,
    label_x     = cos(label_angle) * label_rad,
    label_y     = sin(label_angle) * label_rad
  ) %>%
  ungroup()

angle_dir <- angle %>%
  mutate(
    rad       = .3,
    label_rad = .6,
    label_x   = cos(label_angle) * label_rad,
    label_y   = sin(label_angle) * label_rad
  )

points <- tibble(
  coord = c('x', 'y') %>% rep(2),
  value = c(A_1_START_COORDS_CORR, A_1_END_COORDS_CORR),
  point = c('P', 'Q') %>% rep(each = 2)
) %>%
  pivot_wider(id_cols = point, names_from = coord)

guide_segments <- points %>%
  slice(2 %>% rep(2)) %>%
  mutate(across(x:y, .fns =  ~., .names = "{.col}_0")) %>%
  mutate(x_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(0, x_0)) %>% 
  mutate(y_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(y_0, 0))

item_vector <- points %>% pivot_wider(names_from = point, values_from = x:y)

angle_dir %>% ggplot() +
  geom_abline(slope = tan(-BETA_VALUE)) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = rad, start = init_alt, end = end_alt),
    size = ANGLE_WIDTH
  ) +
  geom_text(
    aes(label_x, label_y, label = angle_label),
    family   = GRAPH_FONT
  ) +
  geom_point(aes(x, y), data = points) +
  # geom_text(
  #   aes(x, y, label = point),
  #   data   = points,
  #   position = position_nudge(y = -.2),
  #   family = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    label  = points$point %>% TeX(italic = TRUE),
    x      = points$x,
    y      = points$y - .15,
    family = GRAPH_FONT
  ) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  geom_segment(
    aes(x_P, y_P, xend = x_Q, yend = y_Q, size = I(VECTOR_WIDTH)),
    data     = item_vector,
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  scale_x_continuous(
    limits = c(-1, 2),
    breaks = 0,
    labels = NULL,
    name   = NULL
  ) +
  scale_y_continuous(
    limits = c(-2, 1),
    breaks = 0,
    labels = NULL,
    name   = NULL
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme(
    axis.line        = element_blank(),
    axis.ticks       = element_blank(),
    panel.grid.major = element_line(color = "black", size = LINE_WIDTH)
  )
```


Finally, in the oblique plane (but pre-multiplying by $`r T_INVERSE`$ instead of
$`r T_MATRIX`$:

\begin{equation}
  `r T_INVERSE` P = \begin{pmatrix}
    1 & `r T_VALUE[1, 2]` \\
    0 & `r T_VALUE[2, 2]`
  \end{pmatrix}
  \begin{pmatrix}
    `r A_1_START_COORDS_CORR[1]` \\
    `r A_1_START_COORDS_CORR[2]`
  \end{pmatrix} =
  \begin{pmatrix}
    `r A_1_START_COORDS_OBLIQUE_CORR[1]` \\
    `r A_1_START_COORDS_OBLIQUE_CORR[2]`
  \end{pmatrix}
\end{equation}

\begin{equation}
  `r T_INVERSE` Q = \begin{pmatrix}
    1 & `r T_VALUE[1, 2]` \\
    0 & `r T_VALUE[2, 2]`
  \end{pmatrix}
  \begin{pmatrix}
    `r A_1_END_COORDS_CORR[1]` \\
    `r A_1_END_COORDS_CORR[2]`
  \end{pmatrix} =
  \begin{pmatrix}
    `r A_1_END_COORDS_OBLIQUE_CORR[1]` \\
    `r A_1_END_COORDS_OBLIQUE_CORR[2]`
  \end{pmatrix}
\end{equation}

```{r graphical-representation-example-vector-oblique-correct, fig.id="graphical-representation-example-vector-oblique-correct", warning=FALSE, fig.cap=glue("Item vector in the oblique space, with corrected director angles and applying the ${T_INVERSE}$ transformation.")}
points_obl <- tibble(
  coord = c('x', 'y') %>% rep(2),
  value = c(A_1_START_COORDS_OBLIQUE_CORR, A_1_END_COORDS_OBLIQUE_CORR),
  point = c('P', 'Q') %>% rep(each = 2)
) %>%
  pivot_wider(id_cols = point, names_from = coord)# %>%
  # mutate(point_label = glue("{T_INVERSE}{point} = {point}_{{oblique}}"))

guide_segments_obl <- guide_segments %>%
  add_column(name = c("H_spike", "V_spike")) %>%
  pivot_longer(cols = where(is.numeric), names_to = "coord") %>%
  mutate(pt = coord %>% str_detect(., "_0") %>% if_else("Q", "axis")) %>%
  group_by(name, pt) %>%
  mutate(value_obl = drop(T_INV_VAL %*% value)) %>%
  ungroup() %>%
  pivot_wider(id_cols = name, names_from = coord, values_from = value_obl)
  
item_vector_obl <- points_obl %>%
  # select(-point_label) %>% 
  pivot_wider(names_from = point, values_from = x:y)

ggplot() +
  geom_abline(slope = tan(RHO_ARC_RAD), size = LINE_WIDTH) +
  geom_hline(yintercept = 0, size = LINE_WIDTH) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = .3, start = pi / 2, end = pi / 2 - RHO_ARC_RAD),
    size = ANGLE_WIDTH
  ) +
  geom_text(
    aes(x = .4, y = .2),
    label  = RHO_ARC %>% number(suffix = 'º'),
    family = GRAPH_FONT
  ) +
  geom_point(aes(x, y), data = points_obl) +
  # geom_text(
  #   aes(x, y, label = point_label),
  #   data     = points_obl,
  #   position = position_nudge(y = -.2),
  #   family   = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    # label  = points_obl$point_label %>% TeX(italic = TRUE),
    label  = expression(
      paste(
        bold(paste("T")),
        phantom()^paste("", "-1"),
        italic("P = P", phantom()[paste("oblique")])
      ),
      paste(
        bold(paste("T")),
        phantom()^paste("", "-1"),
        italic("Q = Q", phantom()[paste("oblique")])
      )
    ),
    x      = points_obl$x - .4,
    y      = points_obl$y - .1,
    family = GRAPH_FONT
  ) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments_obl,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  geom_segment(
    aes(x_P, y_P, xend = x_Q, yend = y_Q, size = I(VECTOR_WIDTH)),
    data     = item_vector_obl,
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  scale_x_continuous(
    limits = c(-1, 2),
    breaks = 0,
    labels = NULL,
    name   = NULL,
    oob = oob_keep
  ) +
  scale_y_continuous(
    limits = c(-2, 1),
    breaks = 0,
    labels = NULL,
    name   = NULL,
    oob = oob_keep
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme(
    axis.line        = element_blank(),
    axis.ticks       = element_blank(),
    panel.grid.major = element_blank()
  )
```


This representation seems to be closer to what would be expected
from the signs of the parameters.
However, there is still an issue:
Given the values of the parameters,
`r A_1_1` and `r A_1_2` for $a_{1_1}$ and $a_{1_2}$, respectively,
one would expect the projection of the vector on the horizontal
axis to be four times as big in magnitude as
the projection on the oblique axis.
However, both projections seem to be roughly equal.

The problem seems to be due to the computation of the coordinates
in the oblique space in the first place.
The matrix of the inner product of the test space (i.e. the item vectors),
according to Zhang & Stout [-@zhang_theoretical_1999],
should be $`r SIGMA`$. However,
as Equation \@ref(eq:T-T-transposed-matrix-product) shows,
$`r T_MATRIX` `r T_MATRIX`'$ is not equal to $`r SIGMA`$.
In fact, $`r T_MATRIX` `r T_MATRIX`' = `r SIGMA`^{-1}$ ($= `r R_MATRIX`^{-1}$
if we assume that all latent trait dimensions are standardized).
Applying Mario's procedure to compute the coordinates, we have that
$`r MBS_DEF` = `r A_TRANSP_T` `r T_TRANSP_A` = `r A_VECTOR` `r SIGMA`^{-1} `r A_VECTOR`'$.
That is, the matrix of the inner product of the test space would be
$`r SIGMA`^{-1}$ instead of $`r SIGMA`$.

Also, the axis projections in this oblique space
should not be orthogonal but oblique.
Therefore, instead of computing the \beta angle and then using its cosine
and sine to compute the horizontal and vertical coordinates, respectively,
the two director cosines need to be computed as [@harman_modern_1970]
$`r DIR_COS_VECTOR` = `r A_VECTOR` `r SIGMA` / `r MBS`$
(note that each of these director cosines already has its proper sign).
Finally, as these coordinates are computed in an oblique space,
we need to transform them to the orthogonal space for representing them
on a two-dimensional display.

We have previously transformed them by pre-multiplying by $`r T_INVERSE`$.
However, this leads to an incorrect representation,
while pre-multiplying by $`r T_MATRIX`'$ gives the proper representation.
The reason for this is still unclear to me, but I think it has to do with
how $`r T_MATRIX`$ and $`r T_INVERSE`$ have been defined.

```{r graphical-representation-example-vector-oblique-corrected-coordinates, fig.id="graphical-representation-example-vector-oblique-corrected-coordinates", warning=FALSE, fig.cap="Item vector in the oblique space after properly computing the multidimensional discrimination paramater."}
points <- tibble(
  coord     = c('x', 'y') %>% rep(2),
  value     = c(A_1_START_COORDS_ORTH_CORRECT, A_1_END_COORDS_ORTH_CORRECT),
  value_obl = c(A_1_START_COORDS_CORRECT, A_1_END_COORDS_CORRECT),
  point     = c('P', 'Q') %>% rep(each = 2)
) %>%
  pivot_wider(
    id_cols     = point,
    names_from  = coord,
    values_from = starts_with("value")
  ) %>%
  rename_with(str_remove, pattern = "^value_") %>%
  mutate(point_label = glue("{T_MATRIX}'{point} = {point}_{{oblique}}"))

guide_segments <- points %>%
  slice(2 %>% rep(2)) %>%
  select(x, y) %>%
  mutate(across(x:y, .fns =  ~., .names = "{.col}_0")) %>%
  mutate(x_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(0, x_0)) %>% 
  mutate(y_0 = 1:n() %>% mod(2) %>% as.logical() %>% if_else(y_0, 0)) %>%
  add_column(name = c("H_spike", "V_spike"))


## TODO: Not sure why this graphical representation (REVIEW)
guide_segments_orth <- guide_segments %>%
  mutate(
    x_0 = if_else(
      name == "V_spike",
      x_0 - y * tan(asin(RHO)),
      x_0 + y * tan(asin(RHO))
    )
  )

  
item_vector_obl <- points %>%
  select(point:y) %>% 
  pivot_wider(names_from = point, values_from = x:y)

ggplot() +
  geom_abline(slope = tan(RHO_ARC_RAD), size = LINE_WIDTH) +
  geom_hline(yintercept = 0, size = LINE_WIDTH) +
  geom_arc(
    aes(x0 = 0, y0 = 0, r = .3, start = pi / 2, end = pi / 2 - RHO_ARC_RAD),
    size = ANGLE_WIDTH
  ) +
  geom_text(
    aes(x = .4, y = .2),
    label  = RHO_ARC %>% number(suffix = 'º'),
    family = GRAPH_FONT
  ) +
  geom_point(aes(x, y), data = points) +
  # geom_text(
  #   aes(x, y, label = point_label),
  #   data     = points_obl,
  #   position = position_nudge(y = -.2),
  #   family   = GRAPH_FONT
  # ) +
  annotate(
    geom   = "text",
    label  = points$point_label %>% TeX(italic = TRUE),
    x      = points$x + .2,
    y      = points$y + .1,
    family = GRAPH_FONT
  ) +
  geom_segment(
    aes(x_0, y_0, xend = x, yend = y),
    data     = guide_segments_orth,
    linetype = "longdash",
    size     = LINE_WIDTH
  ) +
  geom_segment(
    aes(x_P, y_P, xend = x_Q, yend = y_Q, size = I(VECTOR_WIDTH)),
    data     = item_vector_obl,
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  scale_x_continuous(
    limits = c(-.65, 1.65),
    breaks = 0,
    labels = NULL,
    name   = NULL,
    oob    = oob_keep
  ) +
  scale_y_continuous(
    # limits = c(-.5, .5),
    breaks = 0,
    labels = NULL,
    name   = NULL,
    oob    = oob_keep
  ) +
  coord_fixed(expand = FALSE, clip = "off") +
  theme(
    axis.line        = element_blank(),
    axis.ticks       = element_blank(),
    panel.grid.major = element_blank()
  )
```


### Complete procedure for the correct graphical representation

The following compares the two procedures for generating
the graphical representation:
The original one, following Mario's derivation,
and the one that gives the correct representation.

The summary of the procedure according to Mario's derivation implies
the following steps:

1. Compute the item discrimination parameters in the orthogonal space
   $`r A_1_VECTOR_ORTH`$ ($= `r T_MATRIX` `r A_1_VECTOR`$)
   
1. Compute $`r MBS`$
   ($= \sqrt{`r A_1_VECTOR_ORTH`' `r A_1_VECTOR_ORTH`}$)
   
1. Compute $`r MBL`$ ($\tfrac{-l}{`r MBS`}$)

1. Compute the director cosine $\cos \beta$
   ($= \cos \gamma_{i1} = \tfrac{`r A_1_VECTOR_ORTH`}{`r MBS`}$)
   and its complementary sine $\sin \beta$
   ($= \sqrt{1 - \cos^2 \beta}$)

1. Compute the vector origin coordinates $\mathbf{P}$
   ($= `r MBL` (\cos \beta, \sin \beta)$)
   
1. Compute the vector end coordinates $\mathbf{Q}$
   ($= \mathbf{P} - sgn (l_i) `r MBS` (\cos \beta, \sin \beta)$)
   
1. Transform the coordinates $\mathbf{P}$ and $\mathbf{Q}$
   to their equivalent $\mathbf{P}'$ and $\mathbf{Q}'$
   in the oblique space
   ($\mathbf{P}' = `r T_MATRIX` \mathbf{P}; \mathbf{Q}' = `r T_MATRIX` \mathbf{Q}$)


The procedure, according to my corrections, would be as follows:

1. Compute the item discrimination parameters in the orthogonal space
   $`r A_1_VECTOR_ORTH`$ ($= `r T_INVERSE` `r A_1_VECTOR`$)
   
1. Compute $`r MBS`$
   ($= \sqrt{`r A_1_VECTOR_ORTH`' `r A_1_VECTOR_ORTH`} = \sqrt{`r A_1_VECTOR`' `r T_INVERSE`' `r T_INVERSE` `r A_1_VECTOR`}$)
   
1. Compute $`r MBL`$ ($\tfrac{-l}{`r MBS`}$)

1. Compute the director cosine vector
   $`r DIR_COS_VECTOR`$ ($= \tfrac{`r A_VECTOR``r SIGMA`}{`r MBS`}$)
   
1. Compute the origin coordinates $\mathbf{P}$
   ($= `r MBL` `r DIR_COS_VECTOR`$)
   
1. Compute the end coordinates $\mathbf{Q}$
   ($= \mathbf{P} + `r MBS` `r DIR_COS_VECTOR`$)
   
1. Transform the coordinates $\mathbf{P}$ and $\mathbf{Q}$ to their equivalent
   $\mathbf{P}'$ and $\mathbf{Q}'$ in the orthogonal space
   ($\mathbf{P}' = `r T_MATRIX`' \mathbf{P}$;
    $\mathbf{Q}' = `r T_MATRIX`' \mathbf{Q}$)


Therefore, the differences can be summed up in the following four:

1. using $`r T_INVERSE`$ instead of $`r T_MATRIX`$ to transform the coordinates,

1. dropping the coefficient $- sgn(l_i)$ from the second term
   in the computation of $\mathbf{Q}$,

1. computing and using the whole director cosine vector $`r DIR_COS_VECTOR`$
   using the original, oblique discrimination parameter $`r A_VECTOR`$
   multiplied by the covariance matrix $`r SIGMA`$, and
  
1. pre-multiplying the coordinates by $`r T_MATRIX`'$ instead of $`r T_MATRIX`$
   to orthogonalize them.


### Example of graphical representation from my dissertation (Figure 3.1)

Starting from the example in Figure 3.1 in my dissertation,
let's compute and plot the item vectors using the original procedure,
and the one with the corrections.
We need to take into account two things:

- The representation in the orthogonal space does not pose any problem;
  thus, I'll only replicate the example in the oblique space, with $\rho = .5$.

- The parameters in the figure footnote are given in the MUPP-2PL metric,
  so they need to be transformed to the MCLM metric.


The equivalence between the MUPP-2PL and the MCLM parameters
is given elsewhere, e.g. @morillo_dominance_2016.
\@ref(tab:item-params-example-table) gives the parameters in both metrics,
along with the MCLM multidimensional parameters.

```{r set-flextable-wd, cache=FALSE}
# Necessary for officedown to find the template file:
opts_knit$set(root.dir = DOC_DIR)
```

```{r item-params-example-table, tab.id="item-params-example-table", tab.cap="Item parameters for the graphical example"}
MUPP_2PL_params <- tribble(
   ~a_i_1, ~a_i_2, ~l_i, ~dim_i_1, ~dim_i_2,
      2  ,    2  ,  0  ,  1,        2,
      2  ,   -0.5,  1  ,  1,        2,
     -1.5,    1.5, -0.8,  1,        2,
      1.8,    1.3,  1  ,  1,        1,
      1  ,   -1.2, -0.4,  2,        2
)

item_params <- MUPP_2PL_params %>%
  rownames_to_column(var = "item") %>%
  rowwise() %>%
  mutate(
    a_1i         = a_i_1 * (dim_i_1 == 1) - a_i_2 * (dim_i_2 == 1),
    a_2i         = a_i_1 * (dim_i_1 == 2) - a_i_2 * (dim_i_2 == 2),
    l_i_         = l_i,
    a_orth_1i    = T_INV_VAL %*% c_across(a_1i:a_2i) %>% extract(1),
    a_orth_2i    = T_INV_VAL %*% c_across(a_1i:a_2i) %>% extract(2),
    MBS_i        = c_across(a_orth_1i:a_orth_2i) %>%
      { t(.) %*% . } %>%
      drop() %>%
      sqrt(),
    MBL_i        = -l_i_ / MBS_i,
    cos_gamma    = c_across(a_1i:a_2i) %*% CORR_MATRIX / MBS_i,
    cos_gamma_1i = cos_gamma[, 1],
    cos_gamma_2i = cos_gamma[, 2]
  ) %>%
  select(-starts_with("a_orth"), -cos_gamma)

## TODO: Revisar notación de los parámetros (subíndices)
item_params_output <- item_params %>%
  flextable() %>%
  set_header_df(
    tibble(
      col_keys = item_params %>% colnames(),
      metric   = c(
        "Item",
        "MUPP-2PL"    %>% rep(3),
        "Dim."        %>% rep(2),
        "MCLM"        %>% rep(3),
        "Md. params." %>% rep(4)
      ),
      param    = c(
        "Item",
        "a_{i_{1}}", "a_{i_{2}}", "l_i",
        "i_1",       "i_2",
        "a_{1i}",    "a_{2i}",    "l_i",
        "MBS_i",     "MBL_i",     "\\cos \\gamma_{1i}", "\\cos \\gamma_{2i}"
      )
    )
  ) %>%
  mk_par(
    i = 2, j = -1,
    part = "header",
    value = as_paragraph(as_equation(.)),
    use_dot = TRUE
  ) %>%
  merge_v(part = "header") %>%
  merge_h(part = "header", i = 1) %>%
  colformat_double(j = 10:13, digits = 3) %>%
  theme_vanilla() %>%
  add_footer_lines(
    values = paste(
      "Note: Dim. = Dimension;",
      "Md. params. = Multidiemnsional parameters"
    )
  ) %>%
  align(align = "center", part = "header") %>%
  set_table_properties(layout = "autofit")

item_params_output
```


Using these parameters, let's compute the graphical
representation according to Mario's original proposal.
The following R code implements the computation of the coordinates,
with the resulting plot below.
The MCLM parameters $a_{1i}$, $a_{2i}$, and $l_i$
are represented in variables `a_1i`, `a_2i`, and `l_i`, respectively.

```{r item-params-Marios-version, cache=FALSE, echo=TRUE}
item_coords <- item_params %>%
  rowwise() %>%
  mutate(
    a_orth_1i = T_VALUE %*% c_across(a_1i:a_2i) %>% extract(1),
    a_orth_2i = T_VALUE %*% c_across(a_1i:a_2i) %>% extract(2),
    MBS_i     = c_across(a_orth_1i:a_orth_2i) %>%
      { t(.) %*% . } %>%
      drop() %>%
      sqrt(),
    MBL_i     = -l_i_ / MBS_i,
    cos_beta  = a_orth_1i / MBS_i,
    sin_beta  = sqrt(1 - cos_beta^2),
    P_1       = MBL_i * cos_beta,
    P_2       = MBL_i * sin_beta,
    Q_1       = P_1 - sign(l_i) * MBS_i * cos_beta,
    Q_2       = P_2 - sign(l_i) * MBS_i * sin_beta,
    P_1_orth = T_VALUE %*% c_across(P_1:P_2) %>% extract(1),
    P_2_orth = T_VALUE %*% c_across(P_1:P_2) %>% extract(2),
    Q_1_orth = T_VALUE %*% c_across(Q_1:Q_2) %>% extract(1),
    Q_2_orth = T_VALUE %*% c_across(Q_1:Q_2) %>% extract(2)
  )
```

```{r item-params-Marios-version-plot, fig.width=6}
palette <- c("darkred", "darkgoldenrod3", "green3", "cyan3", "blue3")

item_coords %>%
  ggplot(
    aes(
      P_1_orth, P_2_orth,
      xend  = Q_1_orth, yend = Q_2_orth,
      size  = I(VECTOR_WIDTH),
      color = item, fill = item
    ),
  ) +
  geom_segment(
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  geom_abline(slope = tan(RHO_ARC_RAD), size = LINE_WIDTH) +
  geom_abline(
    slope     = tan(RHO_ARC_RAD),
    intercept = -tan(RHO_ARC_RAD) * (-5:4),
    size      = LINE_WIDTH,
    linetype  = "17"
  ) +
  geom_hline(yintercept = 0, size = LINE_WIDTH) +
  scale_x_continuous(
    limits       = c(-3, 3),
    breaks       = (-1:4) - 2 / tan(RHO_ARC_RAD),
    labels       = -1:4,
    minor_breaks = NULL,
    name         = NULL,
    oob          = oob_keep
  ) +
  scale_y_continuous(
    limits       = c(-2, 3.6),
    breaks       = -3:4 * cos(RHO),
    labels       = function(x) x / cos(RHO),
    minor_breaks = 0,
    name         = NULL,
    oob          = oob_keep
  ) +
  scale_color_manual(values = palette) +
  coord_fixed(expand = FALSE, clip = "on") +
  theme(
    axis.line          = element_blank(),
    panel.grid.major.y = element_line(
      color    = "black",
      size     = LINE_WIDTH,
      linetype = "17"
    )
  )
```

As we can see, the item lengths and directions do not correspond to what would
be expected by looking at \@ref(tab:item-params-example-table).
Particularly, item 1 has length 0 due to the fact that $l_1 = 0$ according to
Mario's procedure, and thus $sgn(l_1) = 0$;
therefore, the coefficient $sgn(l_i)$ in Equation \@ref(eq:point-Q)
yields coordinate values of 0 for point $Q$.

Using the corrected procedure I outlined above,
the code for computing the coordinates and resulting plot are:

```{r item-params-corrected-version, cache=FALSE, echo=TRUE}
item_coords <- item_params %>%
  rowwise() %>%
  mutate(
    a_orth_1i    = T_INV_VAL %*% c_across(a_1i:a_2i) %>% extract(1),
    a_orth_2i    = T_INV_VAL %*% c_across(a_1i:a_2i) %>% extract(2),
    MBS_i        = c_across(a_orth_1i:a_orth_2i) %>%
      { t(.) %*% . } %>%
      drop() %>%
      sqrt(),
    MBL_i        = -l_i / MBS_i,
    cos_gamma = c_across(a_1i:a_2i) %*% CORR_MATRIX / MBS_i,
    P_1       = MBL_i * cos_gamma[, 1],
    P_2       = MBL_i * cos_gamma[, 2],
    Q_1       = P_1 + MBS_i * cos_gamma[, 1],
    Q_2       = P_2 + MBS_i * cos_gamma[, 2],
    P_1_orth = t(T_VALUE) %*% c_across(P_1:P_2) %>% extract(1),
    P_2_orth = t(T_VALUE) %*% c_across(P_1:P_2) %>% extract(2),
    Q_1_orth = t(T_VALUE) %*% c_across(Q_1:Q_2) %>% extract(1),
    Q_2_orth = t(T_VALUE) %*% c_across(Q_1:Q_2) %>% extract(2)
  )
```

```{r item-params-corrected-version-plot, fig.width=6}
item_coords %>%
  ggplot(
    aes(
      P_1_orth, P_2_orth,
      xend  = Q_1_orth, yend = Q_2_orth,
      size  = I(VECTOR_WIDTH),
      color = item, fill = item
    ),
  ) +
  geom_segment(
    arrow    = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin = "mitre"
  ) +
  geom_abline(slope = tan(RHO_ARC_RAD), size = LINE_WIDTH) +
  geom_abline(
    slope     = tan(RHO_ARC_RAD),
    intercept = -tan(RHO_ARC_RAD) * (-4:4),
    size      = LINE_WIDTH,
    linetype  = "17"
  ) +
  geom_hline(yintercept = 0, size = LINE_WIDTH) +
  scale_x_continuous(
    limits       = c(-3, 3),
    breaks       = (-1:4) - 2 / tan(RHO_ARC_RAD),
    labels       = -1:4,
    minor_breaks = NULL,
    name         = NULL,
    oob          = oob_keep
  ) +
  scale_y_continuous(
    limits       = c(-2, 2.8),
    breaks       = -3:3 * cos(RHO),
    labels       = function(x) x / cos(RHO),
    minor_breaks = 0,
    name         = NULL,
    oob          = oob_keep
  ) +
  scale_color_manual(values = palette) +
  coord_fixed(expand = FALSE, clip = "on") +
  theme(
    axis.line          = element_blank(),
    panel.grid.major.y = element_line(
      color    = "black",
      size     = LINE_WIDTH,
      linetype = "17"
    )
  )
```

The vectors in this representation seem to match the expected lengths and
directions of the vectors given the multidimensional parameters in
\@ref(tab:item-params-example-table).
Also, the representation is coincident with the right panel in Figure 3.1
of my dissertation.


# Next steps

- Clarifying whether $`r T_MATRIX`$ and $`r T_INVERSE`$ are interchanged;
  note that $`r T_MATRIX`$ is defined as the square root matrix of $`r SIGMA`$
  (when all the variables are standardized),
  and therefore this equivalence should hold for that case.
  Remember to see also Zhang & Stout [-@zhang_theoretical_1999, p. 221].
  
- There is also another pending fact, which is the relationship between
  $`r T_MATRIX`$, $`r SIGMA`$, and $`r R_MATRIX`$.
  If $`r T_MATRIX`$ is defined as the squared root of $`r SIGMA`$,
  then it is an *orthonormalizing* instead of orthogonalizing matrix.
  However, for the graphical representation, one needs to *orthogonalize*
  without standardizing.
  This issue comes from the ambiguity used (by me) between $`r SIGMA`$ and
  $`r T_MATRIX`$, as I (incorrectly) assume that $`r SIGMA`$ is standardized.
  I think this can be resolved by being more strict with the definitions,
  as in section \@ref(matrix-squared).

- These issues are important for clarifying the notation and the graphical
  representation.
  However, for computing the multidimensional parameters,
  I think we should strictly follow Reckase & McKinley's
  [-@reckase_difficulty_1985, -@reckase_discriminating_1991]
  procedure in the first place.


# References
