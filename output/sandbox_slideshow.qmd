---
bibliography:  ../www/Multidimensional-parameters-MCLM.bib
csl:           ../www/apa-old-doi-prefix.csl
date-meta:     "2024-11-27"
editor:
  mode:        source
  markdown: 
    wrap:      sentence
    canonical: true
lang:          es
knitr:
  opts_chunk: 
    results:   asis
    cache:     false
    autodep:   true
format:
  revealjs:
    auto-stretch:            true
    code-annotations:        hover
    df-print:                paged
    fig-cap-location:        bottom
    fig-format:              svg
    fig-asp:                 1
    fig-width:               6
    keep-md:                 true
    link-external-newwindow: true
    margin:                  0
    self-contained:          true
    slide-number:            false
    theme:                   ../www/slideshow-assets/extra-styles.scss
editor_options: 
  chunk_output_type: console
---

```{r libraries}
#| cache:   false
#| include: false

library(tibble)
library(dplyr)
library(knitr)
library(lavaan)
library(semPlot)
library(extrafont)
library(tidyr)
library(ggplot2)
library(units)
library(ggtext)
library(ggridges)
library(qgraph)
library(stringr)
library(purrr)
library(plotly)
library(metR)
library(scales)
```

```{r setup}
#| cache:   false
#| include: false
opts_knit$set(root.dir = here::here()) # See lines 41-42

# Graphical configuration options:
loadfonts(device = "win") # Load fonts (if necessary)
par(family = "Arial", adj = 0.5) # Set graphical device params
```

```{r sources}
source("R/LaTeX_math.R",   encoding = 'UTF-8')
source("R/Output.R",       encoding = 'UTF-8')
source("R/Mirt_toolbox.R", encoding = 'UTF-8')
```

```{r color-palettes}
MARGINS <- c(12, 1.3, 8, 1.3) # margins for the sem path plots

PALETTE_UNED <- c(
  normal = "#00533e",
  medium = "#427562",
  light  = "#86a699",
  white  = "#cddad5"
)
PALETTE_APPLE <- c(
  normal = "#749f4c",
  medium = "#8aac5d",
  light  = "#a2bc7e",
  white  = "#cddbb8"
)
PALETTE_BLUE <- c(
  normal = "#5c6eb1",
  medium = "#7683bd",
  light  = "#929acb",
  white  = "#d4d6eb"
)
PALETTE_TANGERINE <- c(
  normal = "#d76f47",
  medium = "#dd8964",
  light  = "#e4a482",
  white  = "#f0cfb9"
)
PALETTE_STRAWBERRY <- c(
  normal = "#da5268",
  medium = "#c87384",
  light  = "#daa6b1",
  white  = "#efdbdf"
)
PALETTE_RASPBERRY <- c(
  normal = "#90214a",
  medium = "#8e4d60",
  light  = "#af848b",
  white  = "#dac7c7"
)

GRAPH_FONT   <- "Arial"  # Replace default font to comply with UNED identity
FONT_SIZE    <- 24       # Replace default font size for slideshow
AXIS_LAB_POS <-  0.5     # Replace default axis label position for slideshow
LINE_WIDTH   <-  0.75    # Replace default line width for slideshow
GRID_WIDTH   <-  0.5     # Width for grid and axis lines
AXIS_COLOR   <- "gray70" # Replace default grid line color for slideshow
VECTOR_WIDTH <- 1.5      # Replace default vector width for slideshow
```

```{r graphical-output-conf}
#| cache: false
theme_set( # `ggplot` output configuration
  theme_classic(
    base_size      = FONT_SIZE,
    base_family    = GRAPH_FONT,
    base_line_size = LINE_WIDTH
  ) %+replace%
    theme(
      axis.title.x       = element_text(hjust = AXIS_LAB_POS),
      axis.title.y       = element_text(vjust = AXIS_LAB_POS, angle = 0),
      axis.title.y.right = element_text(vjust = AXIS_LAB_POS, angle = 0),
      panel.grid         = element_line(color = AXIS_COLOR),
      panel.grid.minor   = element_line(linetype = "17", color = AXIS_COLOR)
    )
)
```

```{r pre}
PROB_AXIS    <- seq(-3, 3, by = .01)
ERROR_POINTS <- seq(-3, 3, length.out = 5)
PROB_AXIS_2D <- seq(-3, 3, by = .1)
F1_COLOR <- unname(PALETTE_BLUE["normal"])

logit <- function(x) 1 / (1 + exp(-x))
irf   <- function(a, b, theta) logit(a * (theta - b))

mirt_item <- tribble(
  ~item, ~a_1, ~a_2, ~d,
  1,     1,    0.5,  -0.5
)

mirt_item_probs <- expand_grid(
  trait_2 = PROB_AXIS_2D,
  trait_1 = PROB_AXIS_2D
) |>
  mutate(
    mirt_item |>
      select(-item) |>
      pmap(irs2d, theta_1 = trait_1, theta_2 = trait_2) |>
      bind_cols()
  ) |>
    rename(prob = `...1`)

ITEMS_PALETTE <- c(
  PALETTE_BLUE["normal"],
  PALETTE_RASPBERRY["normal"],
  PALETTE_APPLE["normal"],
  PALETTE_TANGERINE["normal"],
  PALETTE_UNED["normal"]
) |>
  unname() |>
  setNames(1:5)
```

## Supuestos: Ortogonalidad {.smaller}

> \[...\] before performing the differentiation, the constraint that Σ cos^2^**α** = 1 is added to the expression for the slope \[...\]

---@reckase_difficulty_1985 [p. 404]

::::: columns
::: column
```{r oblique-rotation-axis-1}
LIM_INF <- -0.5
LIM_SUP <-  2.5

axis_lims <- c(LIM_INF, LIM_SUP)

point <- tibble(F1 = 2, F2 = .2)

point_spikes <- point      |>
  add_column(type = "end")                      |> 
  bind_rows(tibble(F1 = 0, F2 = 0))             |>
  complete(F1, F2, fill = list(type = "start")) |>
  filter(F1 != 0 | F2 != 0)

point_spikes <- point_spikes                           |> 
  bind_rows(point_spikes |> slice(3))                  |>
  mutate(n = paste0('F', (row_number() + 1) %% 2 + 1)) |>
  pivot_wider(names_from = type, values_from = F1:F2)

point |>
  ggplot(mapping = aes(F1, F2))            +
  geom_segment(
    data    = point_spikes,
    mapping = aes(F1_start, F2_start, xend = F1_end, yend = F2_end),
    inherit.aes = FALSE,
    linewidth = LINE_WIDTH,
    linetype  = '43',
  )                                        +
  geom_point(size = I(4))                  +
  scale_x_continuous(
    limits = axis_lims,
    breaks = 0,
    labels = NULL,
    name   = NULL
  )                                        +
  scale_y_continuous(
    limits = axis_lims,
    breaks = 0,
    labels = NULL,
    name   = NULL
  )                                        +
  coord_fixed(expand = FALSE, clip = "on") +
  theme(
    axis.line          = element_blank(),
    axis.ticks         = element_blank(),
    panel.grid.major   = element_line(
      color     = "black",
      linewidth = GRID_WIDTH
    )
  )
```
:::

::: column
:::
:::::

::: notes
Ahora, la TRI multidimensional también dijimos que se interesaba sobre todo por medir (y ordenar) a las personas, no tanto por interpretar sustantivamente esas dimensiones de rasgo latente.
De ahí que estimar un modelo con suficientes dimensiones para explicar la variabilidad entre los sujetos fuese importante, pero no era tan importante cuáles fueran esas dimensiones.
Por eso, hay un supuesto, implícito muchas veces en TRI, de que las dimensiones no están correlacionadas: Se estima el modelo con N dimensiones, las que haga falta, añadiendo restricciones a los ítems para identificarlas, y eso da lugar a N dimensiones independientes entre sí (con correlaciones de 0), representadas en N ejes ortogonales (ángulos rectos todos ellos).
Que esos ejes representen competencia o habilidad en esto o lo otro, en principio, nos da igual.
Con asegurarnos de que hay suficientes dimensiones para "capturar" toda la variabilidad debida a esos rasgos nos basta.

Pues bien, ese es el otro supuesto que hace Reckase para calcular los parámetros multidimensionales: Los cosenos directores del ítem al cuadrado suman 1.
Es decir, está aplicando el teorema de Pitágoras.
Esta expresión implica, de manera implícita, que todos los ejes del espacio latente son "ortogonales" entre sí.
Como digo, en TRI originalmente no importaba mucho que los ejes se pudieran interpretar como rasgos latentes.
No obstante, en 1999 llega McDonald, y dice que la TRI y el AF son fundamentalmente la misma cosa.
:::

## Supuestos: Ortogonalidad {.smaller}

<!-- TODO: Equation as LaTeX -->

> ~~\[...\] before performing the differentiation, the constraint that Σ cos^2^**α** = 1 is added to the expression for the slope \[...\]~~

---@reckase_difficulty_1985 [p. 404]

<!-- # TODO: Coordenadas rectangulares resultantes de una rotación oblicua -->

::::: columns
::: column
```{r oblique-rotation-axis-2}
SEC_COLOR <- "grey60"

BASIS_VEC_1 <- c(1, 0)
BASIS_VEC_2 <- c(4, 1) / sqrt(17)

axis_lims  <- c(LIM_INF, LIM_SUP)
axis_slope <- BASIS_VEC_2[2] / BASIS_VEC_2[1]
transf_matrix <- cbind(BASIS_VEC_1, BASIS_VEC_2) |> unname() |> t() |> solve()

# point_transf <- point |>
#   pivot_longer(everything()) |>
#   mutate(value = transf_matrix %*% value |> drop()) |>
#   pivot_wider()
# 
# point_spikes_transf <- point_transf             |>
#   add_column(type = "end")                      |> 
#   bind_rows(tibble(F1 = 0, F2 = 0))             |>
#   complete(F1, F2, fill = list(type = "start")) |>
#   filter(F1 != 0 | F2 != 0)
# 
# point_spikes_transf <- point_spikes_transf             |> 
#   bind_rows(point_spikes_transf |> slice(3))           |>
#   mutate(n = paste0('F', (row_number() + 1) %% 2 + 1)) |>
#   pivot_wider(names_from = type, values_from = F1:F2)

point_spikes_transf <-
  point_spikes |>
    pivot_longer(starts_with("F")) |>
    separate(name, into = c("dim", "coord")) |>
    pivot_wider(names_from = coord, values_from = value) |>
    group_by(n) |>
    mutate(start = (transf_matrix %*% start |> drop())) |>
  pivot_wider(names_from = dim, values_from = start:end)

point |>
  ggplot(mapping = aes(F1, F2)) +
  geom_abline(slope = axis_slope) +
  geom_segment(
    data    = point_spikes_transf,
    mapping = aes(start_F1, start_F2, xend = end_F1, yend = end_F2),
    inherit.aes = FALSE,
    linewidth = LINE_WIDTH,
    linetype  = '43',
    color = SEC_COLOR
  ) +
  geom_point(size = I(4)) +
  scale_x_continuous(
    limits = axis_lims,
    breaks = 0,
    labels = NULL,
    name   = NULL
  ) +
  scale_y_continuous(
    limits = axis_lims,
    breaks = 0,
    labels = NULL,
    name   = NULL
  ) +
  coord_fixed(expand = FALSE, clip = "on") +
  theme(
    axis.line          = element_blank(),
    axis.ticks         = element_blank(),
    panel.grid.major   = element_line(linewidth = GRID_WIDTH),
    panel.grid.major.x = element_line(color = SEC_COLOR),
    panel.grid.major.y = element_line(color = "black")
  )
```
:::

::: column
:::
:::::

::: notes
Pero en AF tenemos dimensiones correlacionadas la mayoría de las veces, y eso como hemos visto implica hacer rotaciones oblicuas, que dan lugar a ejes no ortogonales.
Luego esta restricción que propone Reckase parece que en principio no se podría aplicar.

\[NEXT\]

Las coordenadas resultantes de cualquier rotación oblicua las podemos representar sin ningún problema en ejes rectangulares (las llamadas "coordenadas Cartesianas").
Pero algo parece fallar cuando generalizamos los parámetros multidimensionales de TRI que hemos mostrado antes a esos espacios de coordenadas no ortogonales.
Si rotamos los ejes de coordenadas, pero los ítems siguen siendo los mismos, es de esperar que la discriminación multidimensional de un ítem (i.e., la "longitud" de su vector) no cambie.
Esta propiedad se llama invarianza.
Veámoslo con un ejemplo.
:::

## References
