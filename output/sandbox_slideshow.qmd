---
bibliography:  ../www/Multidimensional-parameters-MCLM.bib
csl:           ../www/apa-old-doi-prefix.csl
date-meta:     "2024-11-27"
editor:
  mode:        source
  markdown: 
    wrap:      sentence
    canonical: true
lang:          es
knitr:
  opts_chunk: 
    results:   asis
    cache:     false
    autodep:   true
format:
  revealjs:
    auto-stretch:            true
    code-annotations:        hover
    df-print:                paged
    fig-cap-location:        bottom
    fig-format:              svg
    fig-asp:                 1
    fig-width:               6
    keep-md:                 true
    link-external-newwindow: true
    margin:                  0
    self-contained:          true
    slide-number:            false
    theme:                   ../www/slideshow-assets/extra-styles.scss
editor_options: 
  chunk_output_type: console
---

```{r libraries}
#| cache:   false
#| include: false

library(tibble)
library(dplyr)
library(knitr)
library(lavaan)
library(semPlot)
library(extrafont)
library(tidyr)
library(ggplot2)
library(units)
library(ggtext)
library(ggridges)
library(qgraph)
library(stringr)
library(purrr)
library(plotly)
library(metR)
library(scales)
```

```{r setup}
#| cache:   false
#| include: false
opts_knit$set(root.dir = here::here()) # See lines 41-42

# Graphical configuration options:
loadfonts(device = "win") # Load fonts (if necessary)
par(family = "Arial", adj = 0.5) # Set graphical device params
```

```{r sources}
source("R/LaTeX_math.R",   encoding = 'UTF-8')
source("R/Output.R",       encoding = 'UTF-8')
source("R/Mirt_toolbox.R", encoding = 'UTF-8')
```

```{r color-palettes}
MARGINS <- c(12, 1.3, 8, 1.3) # margins for the sem path plots

PALETTE_UNED <- c(
  normal = "#00533e",
  medium = "#427562",
  light  = "#86a699",
  white  = "#cddad5"
)
PALETTE_APPLE <- c(
  normal = "#749f4c",
  medium = "#8aac5d",
  light  = "#a2bc7e",
  white  = "#cddbb8"
)
PALETTE_BLUE <- c(
  normal = "#5c6eb1",
  medium = "#7683bd",
  light  = "#929acb",
  white  = "#d4d6eb"
)
PALETTE_TANGERINE <- c(
  normal = "#d76f47",
  medium = "#dd8964",
  light  = "#e4a482",
  white  = "#f0cfb9"
)
PALETTE_STRAWBERRY <- c(
  normal = "#da5268",
  medium = "#c87384",
  light  = "#daa6b1",
  white  = "#efdbdf"
)
PALETTE_RASPBERRY <- c(
  normal = "#90214a",
  medium = "#8e4d60",
  light  = "#af848b",
  white  = "#dac7c7"
)

GRAPH_FONT   <- "Arial"  # Replace default font to comply with UNED identity
FONT_SIZE    <- 24       # Replace default font size for slideshow
AXIS_LAB_POS <-  0.5     # Replace default axis label position for slideshow
LINE_WIDTH   <-  0.75    # Replace default line width for slideshow
GRID_WIDTH   <-  0.5     # Width for grid and axis lines
AXIS_COLOR   <- "gray70" # Replace default grid line color for slideshow
VECTOR_WIDTH <- 1.5      # Replace default vector width for slideshow
```

```{r graphical-output-conf}
#| cache: false
theme_set( # `ggplot` output configuration
  theme_classic(
    base_size      = FONT_SIZE,
    base_family    = GRAPH_FONT,
    base_line_size = LINE_WIDTH
  ) %+replace%
    theme(
      axis.title.x       = element_text(hjust = AXIS_LAB_POS),
      axis.title.y       = element_text(vjust = AXIS_LAB_POS, angle = 0),
      axis.title.y.right = element_text(vjust = AXIS_LAB_POS, angle = 0),
      panel.grid         = element_line(color = AXIS_COLOR),
      panel.grid.minor   = element_line(linetype = "17", color = AXIS_COLOR)
    )
)
```

```{r pre}
PROB_AXIS    <- seq(-3, 3, by = .01)
ERROR_POINTS <- seq(-3, 3, length.out = 5)
PROB_AXIS_2D <- seq(-3, 3, by = .1)
F1_COLOR <- unname(PALETTE_BLUE["normal"])

logit <- function(x) 1 / (1 + exp(-x))
irf   <- function(a, b, theta) logit(a * (theta - b))

mirt_item <- tribble(
  ~item, ~a_1, ~a_2, ~d,
  1,     1,    0.5,  -0.5
)

mirt_item_probs <- expand_grid(
  trait_2 = PROB_AXIS_2D,
  trait_1 = PROB_AXIS_2D
) |>
  mutate(
    mirt_item |>
      select(-item) |>
      pmap(irs2d, theta_1 = trait_1, theta_2 = trait_2) |>
      bind_cols()
  ) |>
    rename(prob = `...1`)

ITEMS_PALETTE <- c(
  PALETTE_BLUE["normal"],
  PALETTE_RASPBERRY["normal"],
  PALETTE_APPLE["normal"],
  PALETTE_TANGERINE["normal"],
  PALETTE_UNED["normal"]
) |>
  unname() |>
  setNames(1:5)
```

```{r create-grid-function}
transform_grid <- function(basis,
                           x_limits = c(-4, 4),
                           y_limits = c(-4, 4),
                           break_step = 2,
                           linetype_axis = 'solid',
                           linetype_grid = 'dashed') {
  # Argument checking and formatting: ----
    
  ## Grid plot linetypes
  linetypes <- c(`TRUE` = linetype_axis, `FALSE` = linetype_grid)
  
  ## Basis vectors tangents and norms
  vec_tan <- basis[2, ] / basis[1, ]
  
  ## Axis title positions
  y_axis_titpos <- (y_limits[2] / vec_tan[2] - x_limits[1]) /
    (x_limits[2] - x_limits[1])
  x_axis_titpos <- (x_limits[2] * vec_tan[1] - y_limits[1]) /
    (y_limits[2] - y_limits[1])
  
  # Main: ----
    
  # Define grid limits as a function of the axes limits (in canonical metric):
  grid_box <- expand_grid(x = x_limits, y = y_limits) |> mutate(
    x_lim = if_else(x == x_limits[1], "inf", "sup"),
    y_lim = if_else(y == y_limits[1], "inf", "sup")
  )
  
  # Select delimiting grid vertices, based on the basis vector directions
  grid_bounds <- bind_rows(
    h = grid_box |> mutate(slope = vec_tan[1], limit = y_lim),
    v = grid_box |> mutate(slope = vec_tan[2], limit = x_lim),
    .id = "grid"
  ) |>
    filter(xor(slope > 0, x_lim == y_lim)) |>
    mutate(limit_intercept = y - slope * x) # Compute their intercept
  
  # Transformed (1, 1), expressed in the canonical basis
  unit_point <- basis %*% c(1, 1) |>
    as_tibble() |>
    add_column(name = c('x', 'y') |> paste0('_unit')) |>
    pivot_wider(values_from = V1)
  
  # Grid specifications, in canonical basis
  grid_specs <- grid_bounds |>
    bind_cols(unit_point) |>
    mutate(unit_intercept = y_unit - slope * x_unit) |>
    select(-ends_with("unit")) |>
    mutate(
      n_units  = trunc(limit_intercept / unit_intercept),
      n_breaks = n_units %/% break_step * break_step
    )
  
  # Create vertical grid, if the vertical basis vector is completely vertical
  if (is.infinite(vec_tan[2])) {
    
    # Create vertical grid data
    v_grid <- grid_bounds |>
      filter(grid == "v") |>
      mutate(
        unit     = basis[1, 1],
        n_units  = trunc(x / unit),
        n_breaks = n_units %/% break_step * break_step
      ) |>
      select(grid, limit, n_breaks, unit) |>
      pivot_wider(names_from = "limit", values_from = n_breaks) |>
      reframe(
        coord   = seq(from = inf, to = sup, by = break_step),
        x_coord = coord * unit
      ) |>
      mutate(label_pos = x_coord, ref = as.character(!coord))
    
    # Filter out non-valid grid values
    grid_specs <- grid_specs |> filter(!is.infinite(slope))
    
    # Assign x axis label values and coordinates (for the vertical case)
    x_labels <- v_grid |> select(coord, label_pos)
    
    # Create vertical grid geometry
    geom_vgrid <- geom_vline(
      mapping = aes(xintercept = x_coord, linetype = ref),
      data = v_grid
    )
  }
  
  # Create grid data
  grid <- grid_specs |>
    select(grid, limit, slope, unit_intercept, n_breaks) |>
    pivot_wider(names_from = limit, values_from = n_breaks) |>
    group_by(grid) |>
    reframe(
      slope,
      coord = seq(from = inf, to = sup, by = break_step),
      intercept = coord * unit_intercept
    ) |>
    mutate(
      label_pos = if_else(
        grid == "h",
         intercept   + x_limits[1] * vec_tan[1],
        (y_limits[1] - intercept)  / vec_tan[2]
      ),
      ref = as.character(!intercept)
    )

  # Assign x axis label values and coordinates (accounting for the vertical
  #   special case)
  x_labels <- if (is.infinite(vec_tan[2]))    v_grid |> select(coord, label_pos)
              else       grid |> filter(grid == "v") |> select(coord, label_pos)
    
  grid_plot <- grid |>
    ggplot() +
    geom_abline(
      mapping = aes(
        intercept = intercept,
        slope     = slope,
        linetype  = ref
      )
    )
  
  if (is.infinite(vec_tan[2])) grid_plot <- grid_plot + geom_vgrid
  
  grid_plot +
    scale_x_continuous(
      minor_breaks = NULL,
      breaks = x_labels |> pull(label_pos),
      labels = x_labels |> pull(coord),
      limits = x_limits,
      expand = expansion(),
      name   = NULL,
      sec.axis = dup_axis(name = "*&theta;*~2~", labels = NULL)
    ) +
    scale_y_continuous(
      minor_breaks = NULL,
      breaks = grid |> filter(grid == "h") |> pull(label_pos),
      labels = grid |> filter(grid == "h") |> pull(coord),
      limits = y_limits,
      expand = expansion(),
      name   = NULL,
      sec.axis = dup_axis(name = "*&theta;*~1~", labels = NULL)
    ) +
    scale_linetype_manual(values = linetypes, guide = NULL) +
    coord_fixed() +
    theme(
      axis.ticks   = element_blank(),
      axis.line    = element_blank(),
      axis.title.x       = element_markdown(hjust = y_axis_titpos),
      axis.title.y.right = element_markdown(vjust = x_axis_titpos)
    )
}
```

## Generalización: Ejes oblicuos

<br>

:::::: columns
::: {.column width="33%"}
<center>A</center>

```{r grid-orthogonal-rotation}
#| fig-width: 5
basis <- cbind(
  c(sqrt(.75), -sqrt(.25)),
  c(sqrt(.25), sqrt(.75))
)

transform_grid(basis)
```
:::

::: {.column .fragment width="33%"}
<center>B</center>

```{r grid-ts-basis}
#| fig-width: 5
basis <- cbind(
  c(1, 0),
  c(sqrt(.25), sqrt(.75))
)

transform_grid(basis)
```
:::

::: {.column .fragment width="33%"}
<center>C</center>

```{r grid-ls-basis}
#| fig-width: 5
basis <- t(solve(basis))

transform_grid(basis)
```
:::
::::::

::: notes
El primero yo creo que estamos de acuerdo en que no, ya que solamente es una "rotación ortogonal" (como la llamaríamos en el ámbito psicométrico).
La transformación que se aplica podría dar lugar a correlaciones nulas (es lo que haría la transformación de los ejes mediante Análisis de Componentes Principales), pero las varianzas resultantes no serían estandarizadas.
:::

## Example

```{r}
#| fig-format: png
#| results:    hide
library(gganimate, quietly = TRUE)

p <- ggplot(mtcars, aes(factor(cyl), mpg)) +
  geom_boxplot() +
  # Here comes the gganimate code
  transition_states(
    gear,
    transition_length = 2,
    state_length = 1
  ) +
  enter_fade() +
  exit_shrink() +
  ease_aes('sine-in-out')

animate(p, renderer = gifski_renderer(file = here::here("www/slideshow-assets/anim_plot.gif"), loop = FALSE))
```

![](../www/slideshow-assets/anim_plot.gif)

## References
