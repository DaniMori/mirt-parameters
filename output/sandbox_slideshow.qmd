---
bibliography:  ../www/Multidimensional-parameters-MCLM.bib
csl:           ../www/apa-old-doi-prefix.csl
date-meta:     "2024-11-27"
editor:
  mode:        source
  markdown: 
    wrap:      sentence
    canonical: true
lang:          es
knitr:
  opts_chunk: 
    results:   asis
    cache:     false
    autodep:   true
format:
  revealjs:
    auto-stretch:            true
    code-annotations:        hover
    df-print:                paged
    fig-cap-location:        bottom
    fig-format:              svg
    fig-asp:                 1
    fig-width:               6
    keep-md:                 true
    link-external-newwindow: true
    margin:                  0
    self-contained:          true
    slide-number:            false
    theme:                   ../www/slideshow-assets/extra-styles.scss
editor_options: 
  chunk_output_type: console
---

```{r libraries}
#| cache:   false
#| include: false

library(tibble)
library(dplyr)
library(knitr)
library(lavaan)
library(semPlot)
library(extrafont)
library(tidyr)
library(ggplot2)
library(units)
library(ggtext)
library(ggridges)
library(qgraph)
library(stringr)
library(purrr)
library(plotly)
library(metR)
library(scales)
library(mvtnorm)
```

```{r setup}
#| cache:   false
#| include: false
opts_knit$set(root.dir = here::here()) # See lines 41-42

# Graphical configuration options:
loadfonts(device = "win") # Load fonts (if necessary)
par(family = "Arial", adj = 0.5) # Set graphical device params
```

```{r sources}
source("R/LaTeX_math.R",   encoding = 'UTF-8')
source("R/Output.R",       encoding = 'UTF-8')
source("R/Mirt_toolbox.R", encoding = 'UTF-8')
```

```{r color-palettes}
MARGINS <- c(12, 1.3, 8, 1.3) # margins for the sem path plots

PALETTE_UNED <- c(
  normal = "#00533e",
  medium = "#427562",
  light  = "#86a699",
  white  = "#cddad5"
)
PALETTE_APPLE <- c(
  normal = "#749f4c",
  medium = "#8aac5d",
  light  = "#a2bc7e",
  white  = "#cddbb8"
)
PALETTE_BLUE <- c(
  normal = "#5c6eb1",
  medium = "#7683bd",
  light  = "#929acb",
  white  = "#d4d6eb"
)
PALETTE_TANGERINE <- c(
  normal = "#d76f47",
  medium = "#dd8964",
  light  = "#e4a482",
  white  = "#f0cfb9"
)
PALETTE_STRAWBERRY <- c(
  normal = "#da5268",
  medium = "#c87384",
  light  = "#daa6b1",
  white  = "#efdbdf"
)
PALETTE_RASPBERRY <- c(
  normal = "#90214a",
  medium = "#8e4d60",
  light  = "#af848b",
  white  = "#dac7c7"
)

GRAPH_FONT   <- "Arial"  # Replace default font to comply with UNED identity
FONT_SIZE    <- 24       # Replace default font size for slideshow
AXIS_LAB_POS <-  0.5     # Replace default axis label position for slideshow
LINE_WIDTH   <-  0.75    # Replace default line width for slideshow
GRID_WIDTH   <-  0.5     # Width for grid and axis lines
AXIS_COLOR   <- "gray70" # Replace default grid line color for slideshow
VECTOR_WIDTH <- 1.5      # Replace default vector width for slideshow
```

```{r graphical-output-conf}
#| cache: false
theme_set( # `ggplot` output configuration
  theme_classic(
    base_size      = FONT_SIZE,
    base_family    = GRAPH_FONT,
    base_line_size = LINE_WIDTH
  ) %+replace%
    theme(
      axis.title.x       = element_text(hjust = AXIS_LAB_POS),
      axis.title.y       = element_text(vjust = AXIS_LAB_POS, angle = 0),
      axis.title.y.right = element_text(vjust = AXIS_LAB_POS, angle = 0),
      panel.grid         = element_line(color = AXIS_COLOR),
      panel.grid.minor   = element_line(linetype = "17", color = AXIS_COLOR)
    )
)
```

```{r pre}
PROB_AXIS    <- seq(-3, 3, by = .01)
ERROR_POINTS <- seq(-3, 3, length.out = 5)
PROB_AXIS_2D <- seq(-3, 3, by = .1)
F1_COLOR <- unname(PALETTE_BLUE["normal"])

logit <- function(x) 1 / (1 + exp(-x))
irf   <- function(a, b, theta) logit(a * (theta - b))

mirt_item <- tribble(
  ~item, ~a_1, ~a_2, ~d,
  1,     1,    0.5,  -0.5
)

mirt_item_probs <- expand_grid(
  trait_2 = PROB_AXIS_2D,
  trait_1 = PROB_AXIS_2D
) |>
  mutate(
    mirt_item |>
      select(-item) |>
      pmap(irs2d, theta_1 = trait_1, theta_2 = trait_2) |>
      bind_cols()
  ) |>
    rename(prob = `...1`)

ITEMS_PALETTE <- c(
  PALETTE_BLUE["normal"],
  PALETTE_RASPBERRY["normal"],
  PALETTE_APPLE["normal"],
  PALETTE_TANGERINE["normal"],
  PALETTE_UNED["normal"]
) |>
  unname() |>
  setNames(1:5)
```

## Generalización: Ejes oblicuos

¿Cuál es el sistema de coordenadas de θ para que θ\* tenga correlaciones nulas?

:::::: {.columns .fragment}
::: column
```{r}
x_limits   <- c(-4, 4) # Both limits expressed in canonical metric
y_limits   <- c(-4, 4) # Both limits expressed in canonical metric
break_step <- 2 # "Break units" for both grids, expressed in transformed metric

vec_1 <- c(sqrt(1), sqrt(0))
vec_2 <- c(sqrt(.25), sqrt(.75))
basis <- cbind(vec_1, vec_2) |> unname()

# Basis vectors tangents and norms
vec_tan <- basis[2, ] / basis[1, ]
vec_mod <- basis^2 |> colSums() |> sqrt()

# Define grid limits as a function of the axes limits (in canonical metric):
grid_box <- expand_grid(x = x_limits, y = y_limits) |> mutate(
  x_lim = if_else(x == x_limits[1], "inf", "sup"),
  y_lim = if_else(y == y_limits[1], "inf", "sup")
)

# Select delimiting grid vertices, based on the basis vector directions
grid_bounds <- bind_rows(
  h = grid_box |> mutate(slope = vec_tan[1], limit = y_lim),
  v = grid_box |> mutate(slope = vec_tan[2], limit = x_lim),
  .id = "grid"
) |>
  filter(xor(slope > 0, x_lim == y_lim)) |>
  mutate(limit_intercept = y - slope * x) # Compute their intercept

# x_axis_titpos <- -y_limits[1] +
#   if(is.infinite(vec_1_tan)) 0 else x_limits[2] * vec_1_tan
# x_axis_titjust <- x_axis_titpos / x_axis_span
# y_axis_titpos  <- -x_limits[1] +
#   if(is.infinite(vec_2_tan)) 0 else y_limits[2] / vec_2_tan
# y_axis_titjust <- y_axis_titpos / y_axis_span

# Transformed (1, 1), expressed in the canonical basis
unit_point <- basis %*% c(1, 1) |>
  as_tibble() |>
  add_column(name = c('x', 'y') |> paste0('_unit')) |>
  pivot_wider(values_from = V1)

# Grid specifications, in canonical basis
grid_specs <- grid_bounds |>
  bind_cols(unit_point) |>
  mutate(unit_intercept = y_unit - slope * x_unit) |>
  select(-ends_with("unit")) |>
  mutate(
    n_units  = trunc(limit_intercept / unit_intercept),
    n_breaks = n_units %/% break_step * break_step
  )

if (is.infinite(vec_tan[2])) {
  
  v_grid <- grid_bounds |>
    filter(grid == "v") |>
    mutate(
      unit     = vec_1[1],
      n_units  = trunc(x / unit),
      n_breaks = n_units %/% break_step * break_step
    ) |>
    select(grid, limit, n_breaks, unit) |>
    pivot_wider(names_from = "limit", values_from = n_breaks) |>
    reframe(
      coord   = seq(from = inf, to = sup, by = break_step),
      x_coord = coord * unit
    ) |>
  mutate(label_pos = x_coord, ref = as.character(!coord))

  grid_specs <- grid_specs |> filter(!is.infinite(slope))
  
  geom_vgrid <- geom_vline(
    mapping = aes(xintercept = x_coord, linetype = ref),
    data = v_grid
  )
}

grid <- grid_specs |>
  select(grid, limit, slope, unit_intercept, n_breaks) |>
  pivot_wider(names_from = limit, values_from = n_breaks) |>
  group_by(grid) |>
  reframe(
    slope,
    coord = seq(from = inf, to = sup, by = break_step),
    intercept = coord * unit_intercept
  ) |>
  mutate(
    label_pos = if_else(
      grid == "h",
       intercept   + x_limits[1] * vec_tan[1],
      (y_limits[1] - intercept)  / vec_tan[2]
    ),
    ref = as.character(!intercept)
  )

scale_linetype <- c(`TRUE` = 'solid', `FALSE` = 'dashed')

grid_plot <- grid |>
  ggplot() +
  geom_abline(
    mapping = aes(
      intercept = intercept,
      slope     = slope,
      linetype  = ref
    )
  )

if (is.infinite(vec_tan[2])) grid_plot <- grid_plot + geom_vgrid

grid_plot +
  scale_x_continuous(
    minor_breaks = NULL,
    breaks = grid |> filter(grid == "v") |> pull(label_pos),
    labels = grid |> filter(grid == "v") |> pull(coord),
    limits = x_limits,
    expand = expansion(),
    name   = NULL,
    sec.axis = dup_axis(name = "*&theta;*~2~", labels = NULL)
  ) +
  scale_y_continuous(
    minor_breaks = NULL,
    breaks = grid |> filter(grid == "h") |> pull(label_pos),
    labels = grid |> filter(grid == "h") |> pull(coord),
    limits = y_limits,
    expand = expansion(),
    name   = NULL,
    sec.axis = dup_axis(name = "*&theta;*~1~", labels = NULL)
  ) +
  scale_linetype_manual(values = scale_linetype, guide = NULL) +
  coord_fixed() +
  theme(
    axis.ticks   = element_blank(),
    axis.line    = element_blank(),
    # axis.title   = element_markdown(vjust = y_axis_titjust),
    # axis.title.y = element_markdown(hjust = x_axis_titjust)
    axis.title   = element_markdown(),
    axis.title.y = element_markdown()
  )
```
:::

::: column
:::

::: column
:::
::::::

<!-- # TODO: Opciones de elección de bases oblicuas: rectangular, ejes muy alineados, ejes correctos -->

::: notes
Llegados a este punto, la incógnita es: ¿Qué matriz es $\mathbf{P}$, es decir, la matriz que nos permite pasar de las coordenadas originales, $\mathbf{\theta}$, a las transformadas $\mathbf{\theta^*}$?
Esto es equivalente a decir, ¿cuáles son los ejes originales en los que tenemos que representar $\mathbf{\theta}$?
(Recordad, para que $\mathbf{R^*}$ sea una matriz identidad, 1's en la diagonal y 0's fuera de ella).

\[NEXT\]

En base a lo planteado anteriormente, me gustaría hacer una prueba con vosotras y vosotros.
Supongamos una distribución bivariada de rasgos latentes, con una correlación de .8, bastante alta. ¿Cuál de los siguientes sistemas de coordenadas consideráis que representaría adecuadamente los ejes de una distribución bivariada, de forma que al transformarlos a coordenadas rectangulares obtuviésemos una distribución con correlación de 0?
:::

## References
