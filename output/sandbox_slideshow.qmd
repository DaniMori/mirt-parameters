---
bibliography:  ../www/Multidimensional-parameters-MCLM.bib
csl:           ../www/apa-old-doi-prefix.csl
date-meta:     "2024-11-27"
editor:
  mode:        source
  markdown: 
    wrap:      sentence
    canonical: true
lang:          es
knitr:
  opts_chunk: 
    results:   asis
    cache:     false
    autodep:   true
format:
  revealjs:
    auto-stretch:            true
    code-annotations:        hover
    df-print:                paged
    fig-cap-location:        bottom
    fig-format:              svg
    fig-asp:                 1
    fig-width:               6
    keep-md:                 true
    link-external-newwindow: true
    margin:                  0
    self-contained:          true
    slide-number:            false
    theme:                   ../www/slideshow-assets/extra-styles.scss
editor_options: 
  chunk_output_type: console
---

```{r libraries}
#| cache:   false
#| include: false

library(tibble)
library(dplyr)
library(knitr)
library(lavaan)
library(semPlot)
library(extrafont)
library(tidyr)
library(ggplot2)
library(units)
library(ggtext)
library(ggridges)
library(qgraph)
library(stringr)
library(purrr)
library(plotly)
library(metR)
library(scales)
library(fontawesome)
library(mvtnorm)
library(patchwork)
```

```{r setup}
#| cache:   false
#| include: false
opts_knit$set(root.dir = here::here()) # See lines 43-44

# Graphical configuration options:
loadfonts(device = "win") # Load fonts (if necessary)
par(family = "Arial", adj = 0.5) # Set graphical device params
```

```{r sources}
source("R/Formulae.R",                  encoding = 'UTF-8')
source("R/Output.R",                    encoding = 'UTF-8')
source("R/Mirt_toolbox.R",              encoding = 'UTF-8')
source("src/Graphical_example_paper.R", encoding = 'UTF-8')
```

```{r graphical-constants}
# Color palettes:

PALETTE_UNED <- c(
  normal = "#00533e",
  medium = "#427562",
  light  = "#86a699",
  white  = "#cddad5"
)
PALETTE_APPLE <- c(
  normal = "#749f4c",
  medium = "#8aac5d",
  light  = "#a2bc7e",
  white  = "#cddbb8"
)
PALETTE_BLUE <- c(
  normal = "#5c6eb1",
  medium = "#7683bd",
  light  = "#929acb",
  white  = "#d4d6eb"
)
PALETTE_TANGERINE <- c(
  normal = "#d76f47",
  medium = "#dd8964",
  light  = "#e4a482",
  white  = "#f0cfb9"
)
PALETTE_STRAWBERRY <- c(
  normal = "#da5268",
  medium = "#c87384",
  light  = "#daa6b1",
  white  = "#efdbdf"
)
PALETTE_RASPBERRY <- c(
  normal = "#90214a",
  medium = "#8e4d60",
  light  = "#af848b",
  white  = "#dac7c7"
)

# Factor axis colors:
F1_COLOR <- unname(PALETTE_BLUE["normal"])
F2_COLOR <- unname(PALETTE_RASPBERRY["normal"])

# Item colors:
ITEMS_PALETTE <- c(
  PALETTE_BLUE["normal"],
  PALETTE_RASPBERRY["normal"],
  PALETTE_APPLE["normal"],
  PALETTE_TANGERINE["normal"],
  PALETTE_UNED["medium"]
) |>
  unname() |>
  setNames(1:5)

# Grid breaks:
X_BREAKS <- seq(-3, 3, length.out = 5)

# Probability axes:
PROB_AXIS <- seq(-3.3, 3.3, by = .01)
PROB_AXIS_2D <- seq(-3, 3, by = 0.05) # Axis for the probability contour plots
```

```{r graphical-output-conf}
#| cache: false

# Graphical output constants:
GRAPH_FONT   <- "Arial"  # Replace default font to comply with UNED identity
FONT_SIZE    <- 24       # Replace default font size for slideshow
AXIS_LAB_POS <-  0.5     # Replace default axis label position for slideshow
LINE_WIDTH   <-  0.75    # Replace default line width for slideshow
GRID_WIDTH   <-  0.5     # Width for grid and axis lines
AXIS_COLOR   <- "gray70" # Replace default grid line color for slideshow
VECTOR_WIDTH <- 1.5      # Replace default vector width for slideshow

theme_set( # `ggplot` output configuration
  theme_classic(
    base_size      = FONT_SIZE,
    base_family    = GRAPH_FONT,
    base_line_size = LINE_WIDTH
  ) %+replace%
    theme(
      axis.title.x       = element_text(hjust = AXIS_LAB_POS),
      axis.title.y       = element_text(vjust = AXIS_LAB_POS, angle = 0),
      axis.title.y.right = element_text(vjust = AXIS_LAB_POS, angle = 0),
      panel.grid         = element_line(color = AXIS_COLOR),
      panel.grid.minor   = element_line(linetype = "17", color = AXIS_COLOR)
    )
)

MARGINS <- c(12, 1.3, 8, 1.3) # margins for the sem path plots
```

## Orthogonality {.smaller}

<br>

:::::: columns
::: column
```{r item-oblique-axes-1}
#| fig-align:  center
#| fig-height: 8
#| fig-width:  8
mirt_item <- tribble(
  ~item, ~a_1, ~a_2, ~d,
  1,     0.5,  1,    0
)

mirt_item_params <- mirt_item |>
  compute_mirt_params(d, starts_with('a'))

mirt_item_coords <- mirt_item_params |>
  compute_mirt_coords(D, MDISC, starts_with("cos"), original_coords = FALSE) |>
    rename_with(str_remove, pattern = "transf_")

item_spikes <- mirt_item_coords        |>
  slice(1 |> rep(2))                   |>
  add_column(dim = 'F' |> paste0(1:2)) |>
  mutate(
    origin_1 = if_else(dim == 'F1', end_1, origin_1),
    origin_2 = if_else(dim == 'F2', end_2, origin_2),
  )

mirt_item_coords |>
  ggplot(
    aes(
      origin_1, origin_2,
      xend = end_1,
      yend = end_2,
      color = factor(item), fill = factor(item)
    ),
  )                                                  +
  geom_vline(xintercept = 0, linewidth = GRID_WIDTH) +
  geom_hline(yintercept = 0, linewidth = GRID_WIDTH) +
  geom_segment(
    data = item_spikes,
    mapping = aes(origin_1, origin_2, xend = end_1, yend = end_2),
    linewidth = LINE_WIDTH,
    linetype  = '43',
    color     = PALETTE_BLUE["light"]
  ) +
  geom_segment(
    arrow     = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin  = "mitre",
    linewidth = VECTOR_WIDTH
  ) +
  scale_x_continuous(
    limits       = c(-0.75, 1.5),
    breaks       = (-1:3)/2,
    minor_breaks = NULL,
    name         = NULL,
    expand       = expansion(),
    sec.axis     = dup_axis(name = "*&theta;*^*^~2~", labels = NULL)
  ) +
  scale_y_continuous(
    limits       = c(-0.75, 1.5),
    breaks       = (-1:2)/2,
    minor_breaks = NULL,
    name         = NULL,
    expand       = expansion(),
    sec.axis     = dup_axis(name = "*&theta;*^*^~1~", labels = NULL)
  ) +
  scale_color_manual(values = unname(PALETTE_BLUE["normal"]), guide = NULL) +
  annotate(
    "richtext",
    x = c(0.5, -0.1), y = c(-0.1, 1),
    label         = c("*a*^*^~11~", "*a*^*^~21~"),
    size          = 8,
    label.colour  = NA,
    label.padding = unit(0, "lines"),
    fill = NA
  ) +
  coord_fixed(clip = "on") +
  theme(
    axis.line          = element_blank(),
    axis.title         = element_markdown(size = 20, padding = unit(0, "lines")),
    axis.title.x       = element_markdown(hjust = 1/3),
    axis.title.y.right = element_markdown(vjust = 1/3),
    axis.ticks         = element_blank(),
    panel.grid.major   = element_line(
      linewidth = GRID_WIDTH,
      linetype  = "17"
    )
  )
```
:::

:::: column
$$
  \begin{align}
    \mathbf{a}^*_1 &=
      \begin{bmatrix}
        0.5 \\
        1
      \end{bmatrix}\\
      d^*_1 &= 0
  \end{align}
$$

<br>

::: fragment
$$
  \begin{align}
    MDISC^*_1 &= \sqrt{
        [0.5, 1]
        \begin{bmatrix}
          0.5 \\
          1
        \end{bmatrix}
      } \\
      &= \sqrt{ 0.5 · 0.5 + 1 · 1 } \\
      &= \sqrt{ 0.25 + 1 } \\
      &= \sqrt{ 1.25 } \approx 1.12
  \end{align}
$$
:::
::::
::::::

::: notes
You'll recall that we needed orthogonal axes to apply Reckase's formulas.

So let's say we have these "theta star" axes, ...

\[NEXT\]

...
where we have this item, with discrimination (.5, 1), and we can compute its MDISC.

We may want to transform these axes to another coordinate system, for example, applying an oblique rotation...
:::

## Orthogonality {.smaller}

<br>

::::: columns
::: {.column width="60%"}
```{r item-oblique-axes-2}
#| fig-align:  center
#| fig-height: 8
#| fig-width:  8
BASIS_VEC_1 <- c(1, 0)
BASIS_VEC_2 <- c(-.5, 1)

axis_slope <- BASIS_VEC_2[2] / BASIS_VEC_2[1]
transf_matrix <- cbind(BASIS_VEC_1, BASIS_VEC_2) |> unname()

item_coords_transf <- mirt_item_coords |>
  pivot_longer(-item) |>
  separate(name, into = c("coord", "dim")) |>
  group_by(coord) |>
  mutate(
    dim   = paste0('F', dim),
    value = solve(transf_matrix) %*% value |> drop()
  ) |>
  ungroup() |>
  pivot_wider(names_from = dim)

item_spikes_transf <- item_coords_transf         |>
  select(-item)                                  |>
  filter(coord == "end")                         |>
  bind_rows(tibble(F1 = 0, F2 = 0))              |>
  complete(F1, F2, fill = list(coord = "start")) |>
  filter(F1 != 0 | F2 != 0)

item_spikes_transf <- item_spikes_transf               |>
  bind_rows(item_spikes_transf |> slice(3))            |>
  mutate(n = paste0('F', (row_number() + 1) %% 2 + 1)) |>
  pivot_wider(names_from = coord, values_from = F1:F2)

item_spikes_transf_ob <- item_spikes_transf |>
  pivot_longer(starts_with("F")) |>
  separate(name, into = c("dim", "coord")) |>
  pivot_wider(names_from = coord, values_from = value) |>
  group_by(n) |>
  mutate(
    start = (transf_matrix %*% start |> drop()),
    end   = (transf_matrix %*% end   |> drop())
  ) |>
  pivot_wider(names_from = dim, values_from = start:end)

mirt_item_coords |>
  ggplot(
    aes(
      origin_1, origin_2,
      xend = end_1,
      yend = end_2,
      color = factor(item), fill = factor(item)
    ),
  ) +
  geom_abline(
    intercept = -2:3,
    slope     = -2,
    linewidth = GRID_WIDTH,
    linetype  = "17",
    color     = AXIS_COLOR
  ) +
  geom_abline(slope = -2, linewidth = GRID_WIDTH) +
  geom_hline(yintercept = 0,  linewidth = GRID_WIDTH) +
  geom_segment(
    data = item_spikes_transf_ob,
    mapping = aes(start_F1, start_F2, xend = end_F1, yend = end_F2),
    inherit.aes = FALSE,
    linewidth = LINE_WIDTH,
    linetype  = '43',
    color     = PALETTE_BLUE["light"]
  ) +
  geom_segment(
    arrow     = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin  = "mitre",
    linewidth = VECTOR_WIDTH
  ) +
  scale_x_continuous(
    limits       = c(-0.75, 1.5),
    breaks       = (-2:2)/2 + .375,
    labels       = ~number(. - .375, .1),
    minor_breaks = NULL,
    name         = NULL,
    expand       = expansion(),
    sec.axis     = dup_axis(name = "*&theta;*~2~", labels = NULL)
  ) +
  scale_y_continuous(
    limits       = c(-0.75, 1.5),
    breaks       = (-1:2)/2,
    minor_breaks = NULL,
    name         = NULL,
    expand       = expansion(),
    sec.axis     = dup_axis(name = "*&theta;*~1~", labels = NULL)
  ) +
  scale_color_manual(values = unname(PALETTE_BLUE["normal"]), guide = NULL) +
  annotate(
    "richtext",
    x = c(1, -0.59), y = c(-0.07, 1),
    label         = c("*a*~11~", "*a*~21~"),
    size          = 8,
    label.colour  = NA,
    label.padding = unit(0, "lines"),
    fill = NA
  ) +
  coord_fixed(clip = "on") +
  theme(
    axis.line          = element_blank(),
    axis.title         = element_markdown(size = 20, padding = unit(0, "lines")),
    axis.title.x       = element_markdown(hjust = 0),
    axis.title.y.right = element_markdown(vjust = 1/3),
    axis.ticks         = element_blank(),
    panel.grid.major.y = element_line(
      linewidth = GRID_WIDTH,
      linetype  = "17"
    )
  )
```
:::

::: {.column .fragment width="40%"}
<br> <br>

> \[...\] before performing the differentiation, the constraint that Σ cos^2^**α** = 1 is added to the expression for the slope \[...\]

--- @reckase_difficulty_1985 [p. 404]
:::
:::::

::: notes
...to obtain these "theta axes" which, let's say, align with our measured personality traits.
We have now different discrimination components than in the "theta star" axes.

\[NEXT\]

If we applied here Reckase's restriction...
:::

## Orthogonality {.smaller}

<br>

::::: columns
::: column
```{r item-oblique-axes-4}
#| fig-align:  center
#| fig-height: 8
#| fig-width:  8
mirt_item_transf <- tribble(
  ~item, ~a_1, ~a_2, ~d,
  1,     1,    1,    0
)

mirt_item_params <- mirt_item_transf |>
  compute_mirt_params(d, starts_with('a'))

mirt_item_coords <- mirt_item_params |>
  compute_mirt_coords(D, MDISC, starts_with("cos"), original_coords = FALSE) |>
    rename_with(str_remove, pattern = "transf_")

item_spikes <- mirt_item_coords        |>
  slice(1 |> rep(2))                   |>
  add_column(dim = 'F' |> paste0(1:2)) |>
  mutate(
    origin_1 = if_else(dim == 'F1', end_1, origin_1),
    origin_2 = if_else(dim == 'F2', end_2, origin_2),
  )

mirt_item_coords |>
  ggplot(
    aes(
      origin_1, origin_2,
      xend = end_1,
      yend = end_2,
      color = factor(item), fill = factor(item)
    ),
  )                                                  +
  geom_vline(xintercept = 0, linewidth = GRID_WIDTH) +
  geom_hline(yintercept = 0, linewidth = GRID_WIDTH) +
  geom_segment(
    data = item_spikes,
    mapping = aes(origin_1, origin_2, xend = end_1, yend = end_2),
    linewidth = LINE_WIDTH,
    linetype  = '43',
    color     = PALETTE_BLUE["light"]
  ) +
  geom_segment(
    arrow     = arrow(angle = 20, length = unit(10, "points"), type = "closed"),
    linejoin  = "mitre",
    linewidth = VECTOR_WIDTH
  ) +
  scale_x_continuous(
    limits       = c(-0.75, 1.5),
    breaks       = (-1:3)/2,
    minor_breaks = NULL,
    name         = NULL,
    expand       = expansion(),
    sec.axis     = dup_axis(name = "*&theta;*~2~", labels = NULL)
  ) +
  scale_y_continuous(
    limits       = c(-0.75, 1.5),
    breaks       = (-1:2)/2,
    minor_breaks = NULL,
    name         = NULL,
    expand       = expansion(),
    sec.axis     = dup_axis(name = "*&theta;*~1~", labels = NULL)
  ) +
  scale_color_manual(values = unname(PALETTE_BLUE["normal"]), guide = NULL) +
  annotate(
    "richtext",
    x = c(1, -0.1), y = c(-0.1, 1),
    label         = c("*a*~11~", "*a*~21~"),
    size          = 8,
    label.colour  = NA,
    label.padding = unit(0, "lines"),
    fill = NA
  ) +
  coord_fixed(clip = "on") +
  theme(
    axis.line          = element_blank(),
    axis.title         = element_markdown(size = 20, padding = unit(0, "lines")),
    axis.title.x       = element_markdown(hjust = 1/3),
    axis.title.y.right = element_markdown(vjust = 1/3),
    axis.ticks         = element_blank(),
    panel.grid.major   = element_line(
      linewidth = GRID_WIDTH,
      linetype  = "17"
    )
  )
```
:::

::: column
$$
  \begin{align}
    \mathbf{a}_1 &=
      \begin{bmatrix}
        1 \\
        1
      \end{bmatrix}\\
      d_1 &= 0
  \end{align}
$$

<br>

$$
  \begin{align}
    MDISC_1 &= \sqrt{
        [1, 1]
        \begin{bmatrix}
          1 \\
          1
        \end{bmatrix}
      } \\
      &= \sqrt{ 1 · 1 + 1 · 1 } \\
      &= \sqrt{ 1 + 1 } \\
      &= \sqrt{ 2 } \approx 1.41
  \end{align}
$$
:::
:::::

::: notes
...we would be assuming that the axes are actually orthogonal, which would imply that the MDISC is not invariant.
Also, you can see intuitively that it does not seem right to assume that both coordinate systems are orthogonal, ¿right?
:::

## Orthogonality {.smaller}

<br>

::::: columns
::: column
```{r item-oblique-axes-2}
```
:::

::: column
<br> <br>

> ~~\[...\] before performing the differentiation, the constraint that Σ cos^2^**α** = 1 is added to the expression for the slope \[...\]~~

--- @reckase_difficulty_1985 [p. 404]
:::
:::::

::: notes
:::

## References
